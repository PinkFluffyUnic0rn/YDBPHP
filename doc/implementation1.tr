.
.
.ds Q \(Fo
.ds U \(Fc
.ds - \(em
.ds HSPACE1 3v;1.8v;0.5v;0v
.de H
.sp 3.0
.ps +7
.vs +7
.ft B
\\$1
.ft
.ps -7
.vs -7
.sp 1.0
..
.
.de NDFG
.KF
.sp 1.0v
.PSPIC \\$1 \\$2
.sp 0.25v
.ps -1
.vs -1
.ce 100
.nr NDARGN 3 0
.while (\\n[NDARGN] <= \\n[.$]) \{\
\\$\\n[NDARGN]
.nr NDARGN +1
.\}
.ce 0
.ps +1
.vs +1
.sp 1.0v
.KE
..
.
.de LS
.KS
.nf
.in \n[PI]u
.CW
..
.
.de LE
.KE
..
.
.char \[one] \s-2\v'-0.3m'1\v'+0.3m'\s+2
.
.
.ps +10
.vs +10
.ft B
.ce 2
Расширение PHP для работы с YottaDB
Проект реализации
.ft
.vs -10
.ps -10
.sp 2.5
.PP
Данный документ является описанием предполагаемой реализации расширения
языка PHP, предназначенного для работы с СУБД \*PYottaDB\*P. Реализация
базируется на описанном ранее программном интерфейсе для данного
расширения, который был приведён в виде отдельного документа.
.
.
.H "1. Общая структура расширения"
.PP
Предполагается, что код данного расширения будет выполняться в двух
отдельных процессах: часть кода будет выполняться в процессе
интерпретатора PHP, а часть \*- в дополнительном сопроцессе. Это нужно,
чтобы избежать конфликта, возникающего из-за того, что PHP и YottaDB
могут назначать разные обработчики одним и тем же сигналам. Также это
позволяет избежать определения \*Qчужих\*U переменных окружения в
адресном пространстве интерпретатора PHP.
.PP
Код, выполняемый в интерпретаторе PHP, в большинстве случаев, является
\*Qзаглушкой\*U \*- его задача подготовить аргументы, переданные
пользователем, и сформировать на их основе запрос, который будет
отправлен сопроцессу, затем, дождаться от сопроцесса ответа и вернуть
пользователю полученый в этом ответе результат.
.PP
Сопроцесс выполняет всю работу с базой данных. Получив запрос, он
определяет, какое именно действие необходимо выполнить, затем выполняет
вызов процедуры MUMPS, соответствующей этому действию и возвращает
ответ, поместив в него возвращаемое значение процедуры, если оно
имеется.
.PP
Взаимодействие кода расширения, находяшегося в интерпретаторе PHP, и
работающего с базой данных сопроцесса будет выполняться с помощью
протокола \*IJSON-RPC\*P [1]. Данные между процессами будут передаваться
через неименованые каналы в виде текста, без какого либо шифрования и
сжатия. 
.H "2. Протокол передачи данных пежду процессами"
.PP
Протокол JSON-RPC является текстовым протоколом, используемым для
удалённого вызова процедур, т.е. вызова процедур в другом адресном
пространстве. В данном случае выполняется вызов процедур (функций),
находящихся в адресном пространстве сопроцесса, из интерпретатора PHP.
.PP
Удалённый вызов процедуры процедуры происходит следующим образом:
.sp 0.5
.RS
.PI \(bu
Вызывающая сторона генерирует запрос, указывающий функцию, которую
необходимо вызвать. Также этот запрос содержит аргументы для этой
функции, если они имеются.
.PI \(bu
Получив запрос, выполняющая сторона (удалённый процесс или компьютер)
запускает указанную в запросе функцию и, если требуется, передаёт ей
аргументы, содержащиеся в запросе.
.PI \(bu
После завершения работы запущеной функции, выполняющая сторона
генерирует ответ, содержащий результат выполнения функции или сообщение
об ошибке, если она произошла.
.PI \(bu
Получив ответ, вызывающая сторона извлекает из него результат выполнения
функции или ошибку и продолжает свою работу.
.RE
.sp 0.5
Это можно изобразить как показано на схеме (рис. 1), где \*IPHP\*P \*-
интерпретатор PHP, \*Icoprocess\*P \*- сопроцесс, \*Iprocedure\*P \*-
вызываемая процедура, \*Irequest\*P и \*Iresponse\*P \*- вызов удалённой
процедуры и ответ на неё, а \*Iarguments\*P и \*Ireturn value\*P \*-
аргументы и возвращаемое значение процедуры.
.NDFG rpcscheme.eps 30m "Рис. 1. Схема удалённого вызова процедуры."
.PP
В данном протоколе, как ясно из названия, используется формат JSON.
Описание этого формата можно найти в [2]. Запрос в JSON-RPC будет
выглядеть следующим образом:
.sp 0.5
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"method" : method,
	"params": [param1, param2, ...]
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, \*(CWmethod\*P \*-
строка, содержащая имя вызываемой процедуры, а
\*(CWparam1, param2, ...\*P \*- аргументы, передаваемые вызываемой
процедуре, если они имеются. Несмотря на то, что спецификация
протокола позволяет использовать в качестве аргументов как числа, так и
строки, в данном расширении предполагается представлять аргументы
исключительно строками. Помимо этого спецификация допускает, что в
качестве элемента \*(CWparams\*P может не массив, а объект, однако, в
данном расширении элемент \*(CWparams\*P всегда является массивом.
.PP
Ответ, если удалённая процедура была выполнена без ошибок, выглядит так:
.sp 0.5
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"result": result,
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, результат вызова которого
содержит этот ответ, а \*(CWresult\*P \*- результат вызова. Как и в
случае с аргументами, несмотря на то, что спецификация не ограничивает
тип этого элемента, в данном расширении предполагается использовать
только строки.
.PP
Ответ, если при вызове удалённой процедуры произошла ошибка, выглядит
так:
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"error": {
		"code": errorcode,
		"message": errormessage
	}
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, при вызове которого
произошла ошибка, \*(CWerrorcode\*P \*- числовой код ошибки,
\*(CWerrormessage\*P \*- строка, содержащая текстовое описание ошибки.
Источником ошибки может быть либо сам запрос или ответ, либо база
данных, либо операционная система. В случае ошибки в запросе
спецификацией JSON-RPC предусмотрены следующие коды ошибок:
.sp 1.0
.TS
allbox, center, expand;
c l l.
Код	Сообщение	Значение
-32700	Parse error	Ошибка при разборе JSON-запроса или JSON-ответа.
-32600	Invalid Request	T{
Отправленное JSON-сообщение не является корректным запросом.
T}
-32601	Method not found	Метод не найден или не доступен
-32602	Invalid params	Неверные параметры
-32603	Internal error	Внутренная ошибка JSON-RPC
-32000 \(en -32099	Server error	T{
Зарезервированы под определяемые реализацией ошибки сервера.
T}
.TE
.sp 1.0
.PP
В случае, когда ошибка произошла при работе с базой данных, возвращается
один из кодов ошибок, определенных в [3], в подразделе
\*QZMessage Codes\*U раздела \*QError Message Quick Reference\*U. Также
код ошибки YottaDB можно отличить от других с помощью констант
\*(CWYDB_MIN_YDBERR\*P  и \*(CWYDB_MAX_YDBERR\*P, определённых в файле
заголовков \*(CWlibyottadb.h\*P и указывающих нижнюю и верхнюю границы
диапазона кодов ошибок, используемых в YottaDB. Любые другие ошибки
следует считать ошибками, исходящими от операционной системы.
.PP
Также стоит отметить, что спецификация протокола позволяет использовать
в качестве идентификаторов запросов как целые числа, так и строки,
однако в данном расширении предполагается только использование целых
чисел.
.
.H "3. Обработка запросов и ответов"
.PP
Для чтения запросов и ответов предполагается использовать рекурсивный
парсер. Благодаря простому синтаксису JSON, такой парсер, даже будучи
написанным на C, получится достаточно компактным. Парсер будет разбирать
запросы и ответы, помещая их в соответствующие им структуры C.
.PP
Чтобы упростить разделение получаемых сообщений, а также чтобы снизить
количество выполняемых компьютером обращений к памяти и вычислений,
предполагается объединить чтение и разбор JSON-сообщения в одну функцию.
Текстовые данные будут читаться из неименованного канала \*Qна ходу\*U
разбираясь парсером. Как только будет получен полноценный JSON-объект,
функция будет завершаться и возвращать результат.
.PP
Формирование и отправку JSON-сообщения, также предполагается объединить
в одну функцию. Эта функция будет принимать структуру Си, описывающую
запрос или ответ и формировать на её основе JSON-сообщение, сразу
записывая это сообщение в неименованный канал.
.PP
Ошибки, которые могут происходить при отправке или получении запросов и
ответов могут быть связаны либо с передачей данных, либо с протоколом
передачи данных. В первом случае коды ошибок определяются стандартной
библиотекой Си, а сообщения об ошибках аналогичны сообщениям, получаемым
при вызове функции стандартной библиотеки Си \*(CWstrerror\*P. Во втором
случае коды ошибок определяются перечислением
.sp 0.5
.LS
enum YP_JRERROR {
	YP_ERR_JRPARSE = -32700
	YP_ERR_JRINVALREQ = -32600
	YP_ERR_JRINVALRES = -32001
	YP_ERR_JRREQSTRUCT = -32002
	YP_ERR_JRRESSTRUCT = -32003
}
.LE
.sp 0.5
и имеют следующие значения:
.sp 0.5
.RS
.PI
\*(CWYP_ERR_JRPARSE\*P \*- получен некорректный JSON-объект.
.PI
\*(CWYP_ERR_JRINVALREQ\*P \*- получен некорректный запрос.
.PI
\*(CWYP_ERR_JRINVALRES\*P \*- получен некорректный ответ.
.PI
\*(CWYP_ERR_JRREQSTRUCT\*P \*- структура, содержащая запрос,
некорректна.
.PI
\*(CWYP_ERR_JRRESSTRUCT\*P \*- структура, содержащая ответ, некорректна.
.RE
.sp 0.5
.PP
Данные коды ошибок организованны таким образом, чтобы соответствовать
кодам ошибок JSON-RPC, не пересекаясь диапазоном значений с кодами
ошибок стандартной библиотеки Си и кодами ошибок YottaDB. Текстовое
сообщение, соответствующее последней полученной при отправке или
получении запросов и ответов ошибки можно получить с помощью функции
.sp 0.5
.LS
char *yp_jrstrerror();
.LE
.sp 0.5
, возвращающей указатель на строку, содержающую это описание. Эту строку
нельзя модифицировать.
.PP
Для представления запросов в Си предполагается использовать следующую
структуру:
.sp 0.5
.LS
struct yp_request {
	int id;
	enum METHOD method;
	char **param;
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, \*(CWmethod\*P \*- значение
из перечисления \*(CWYP_METHOD\*P, указывающее, какую функцию необходимо
вызвать, а \*(CWparam\*P \*- набор строк, каждая из которых содержит
значение одного из аргументов вызываемой функции. Перечисление
\*(CWYP_METHOD\*P предлагается определить следующим образом, при
необходимости добавляя в него новые значения:
.sp 0.5
.LS
enum YP_METHOD {
	YP_INIT,
	YP_FINILIZE,
	YP_GET,
	YP_SET,
	YP_KILL,
	YP_DATA,
	YP_ORDER
}
.LE
.sp 0.5
.PP
В данную структуру будут помещаться все полученные и разобранные
парсером ответы. Эта же структура будет заполнятся для формирования
и отправки JSON-сообщений, содержащих ответы.
.PP
Ответы в Си предполагается представлять следующей структурой:
.sp 0.5
.LS
struct yp_response {
	int id;
	char *result;
	int errcode;
	char *errmessage;
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, результат вызова которого
содержит этот ответ, \*(CWresult\*P \*- строка, содержащая результат
вызова запроса, \*(CWerrcode\*P \*- код ошибки, \*(CWerrmessage\*P \*-
текстовое сообщение об ошибке. Отличить ответ с результатом успешного
выполнения функции от сообщения об ошибке можно по элементу
\*(CWresult\*P \*- если его значение равно \*(CWNULL\*P, значит ответ
является сообщением об ошибке, в любом другом случае выполнение было
успешным. Как и в случае с запросами эта структура будет использоваться
как для получения ответов, так и для их отправки.
.PP
Функция для чтения запросов имеет следующий заголовок:
.sp 0.5
.LS
int yp_readrequest(struct yp_request *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- указатель на структуру \*(CWyp_request\*P, куда
следует поместить прочитанный запрос. Помимо ошибок стандартной
библиотеки Си, данная функция может вернуть ошибки с кодами
\*(CWYP_JRPARSE\*P и \*(CWYP_ERR_JRINVALREQ\*P.
.PP
Заголовок функции для чтения ответов выглядит так:
.sp 0.5
.LS
int yp_readresponse(struct yp_response *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- указатель на структуру \*(CWyp_response\*P, куда
будет помещен прочитанный ответ. Помимо ошибок стандартной библиотеки
Си, данная функция может вернуть ошибки с кодами \*(CWYP_ERR_JRPARSE\*P
и \*(CWYP_ERR_JRINVALRES\*P.
.PP
Для генерации и отправки запроса будет использоваться функция с
заголовком
.sp 0.5
.LS
int yp_writerequest(struct yp_request *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- структура \*(CWyp_request\*P, содержащая запрос,
для которого нужно сгенерировать и отправить JSON-сообщение. Помимо
ошибок стандартной библиотеки Си, данная функция может вернуть ошибку с
кодом \*(CWJR_ERR_REQSTRUCT\*P.
.PP
Отправку ответов предполагается осуществлять функцией 
.sp 0.5
.LS
int yp_writeresponse(struct yp_response *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- структура \*(CWyp_response\*P, содержащая ответ,
который нужно сгенерировать и отправить. Помимо ошибок стандартной
библиотеки Си, данная функция может вернуть ошибку с кодом
\*(CWJR_ERR_RESSTRUCT\*P.
.H "4. Работа с запросами в PHP расширении"
.PP
Как уже было написано выше, большая часть кода данного расширения,
исполняющиюся в интерпретаторе PHP, является \*Qзаглушкой\*U.
Исключением является код, выполняемый в \*Iфункциях-ловушках\*P
(hooks) \*- \*(CWRINIT\*P и \*(CWRSHUTDOWN\*P (см. [5], подраздел
\*QLearning the PHP lifecycle\*U раздела \*QExtensions design\*U).
.PP
Функция \*(CWRINIT\*P в процессе интерпретатора запускается перед
началом обработки очередного CGI-запроса. В данном расширении,
\*(CWRINIT\*P отвечает за инициализацию сопроцесса. Выглядит это так:
.sp 0.5
.RS
.PI 1.
Создать два неименованных канала с помощью системного вызова
\*(CWpipe\*P \*- один для передачи запросов, другой для передачи
ответов. В случае ошибки:
.RS
.PI \(bu
Поместить значение глобальной переменной
\*(CWerrno\*P в глобальную переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова фукнции
\*(CWstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 2.
Запустить сопроцесс с помощью системного вызова \*(CWfork\*P. В случае
ошибки:
.RS
.PI \(bu
Поместить значение глобальной переменной \*(CWerrno\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова фукнции
\*(CWstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 3.
В сопроцессе:
.RS
.PI a.
Закрыть конец для записи в неименованном канале, предназначенном для
передачи запросов.
.PI b.
Закрыть конец для чтения в неименованном канале, предназначенном для
передачи ответов.
.PI c.
Запустить основной цикл сопроцесса (будет описан в разделе 4).
.RE
.PI 4.
В интерпретаторе PHP:
.RS
.PI a.
Закрыть конец для чтения в неименованном канале, предназначенном для
передачи запросов.
.PI b.
Закрыть конец для записи в неименованном канале, предназначенном для
передачи ответов.
.RE
.PI 5.
Сформировать запрос для вызова в сопроцессе функции \*(CWydb_init\*P
(которая будет описана в разделе 5 данного документа) c аргументами,
задающими переменные окружения, которые были переданы пользователем
PHP в функцию \*(CWydb_init\*P в интерпретаторе.
.PI 6.
С помощью функции \*(CWyp_writerequest\*P отправить сформированный
запрос сопроцессу. Если произошла ошибка:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 7.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если данная функция завершилась с ошибкой:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_readresponse\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 8.
Если поле \*(CWresult\*P, полученного ответа \*- пустая строка, вернуть
\*(CWTrue\*P, если же поле \*(CWresult\*P \*- \*(CWNULL\*P:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 9.
Вернуть \*(CWTrue\*P.
.RE
.sp 0.5
.PP
Функция \*(CWMSHUTDOWN\*P запускается в процессе интерпретатора после
обработки очередного CGI-запроса. В ранном расширении \*(CWMSHUTDOWN\*P
выполняет действия, необходимые для завершения работы сопроцесса.
Выполняемые ей действия можно записать так:
.sp 0.5
.RS
.PI 1.
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW0\*P.
.PI 2.
С помощью функции \*(CWyp_writerequest\*P отправить запрос для вызова в
сопроцессе функции \*(CWydb_finilize\*P (будет описана в разделе 4
данного документа). Если произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.PI \(bu
Перейти к пункту 5.
.RE
.PI 3.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если при получении ответа произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_readresponse\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.PI \(bu
Перейти к пункту 5.
.RE
.PI 4.
Если поле \*(CWresult\*P полученного ответа равно \*(CWNULL\*P:
.RS
.PI \(bu
Поместить содержимое поля \*(CWerrcode\*P в глобальную переменную
\*(CWyp_errcode\*P.
.PI \(bu
Поместить содержимое поля \*(CWerrmessage\*P в глобальную переменную
\*(CWyp_errmessage\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.RE
.PI 5.
Закрыть неименованные каналы для передачи данных.
.PI 6.
Получить код завершения сопроцесса с помощью функции \*(CWwait\*P. Если
код не равен нулю:
.RS
.PI \(bu
Присвоить глобальной переменной \*(CWyp_errcode\*P значение
\*(CWYDB_ERR_ABNORMEND\*P.
.PI \(bu
Присвоить глобальной переменной \*(CWyp_errmessage\*P значение
\*(CW"Coprocess ended abnormaby."\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.RE
.PI 7.
Если значение переменной \*(CWiserror\*P равно \*(CW0\*P, вернуть
\*(CWTrue\*P, иначе вернуть \*(CWFalse\*P.
.RE
.sp 0.5
.PP
Функции \*(CWydb_set\*P, \*(CWydb_get\*P, \*(CWydb_gettyped\*P,
\*(CWydb_kill\*P, \*(CWydb_data\*P и \*(CWydb_order\*P, как уже
упоминалось, формируют запрос, содержащий переданные им аргументы,
отправляют его, дожидаются ответа и возвращают результат выполнения
функции в сопроцессе, содержащийся в этом ответе.
.PP
Первые аргументы приведённых выше функций \*- \*(CWvar\*P и произвольное
число аргументов \*(CWkeys\*P (см. описание программного интерфейса)
обрабатываются одинаковым образом. Эти аргументы преобразуются в одну
цельную строку, всегда помещаемую в запрос в качестве первого аргумента
и указывающую переменную или элемент массива, над которым нужно
выполнить действие.  Данное преобразование выглядит так:
.sp 0.5
.RS
.PI 1.
Инициализировать строку \*(CWs\*P значением переданного пользователем
PHP аргумента \*(CWvar\*P.
.PI 2.
Если пользователем PHP был передан хотя бы один аргумент \*(CWkeys\*P,
добавить к строке \*(CWs\*P символ \*Q\*(CW(\*P\*U.
.PI 3.
Для каждого переданного пользователем PHP аргумента \*(CWkeys\*P, с
первого такого аргумента по последний:
.RS
.PI a.
Если этот аргумент является строкой, присоединить его к \*(CWs\*P,
дополнив символом \*Q\*(CW,\*P\*U.
.PI b.
Если этот аргумент является числом, преобразовать его в строку и
присоединить к \*(CWs\*P, дополнив символом \*Q\*(CW,\*P\*U.
.PI c.
Если этот аргумент является массивом PHP с целочисленными ключами, то
для каждого его элемента массива, с первого по последний:
.RS
.PI \(bu.
Если данный элемент является строкой, присоединить его к \*(CWs\*P,
дополнив символом \*Q\*(CW,\*P\*U.
.PI \(bu.
Если данный элемент является числом, приобразовать его в строку и
присоединить к \*(CWs\*P, дополнив символом \*Q\*(CW,\*P\*U.
.RE
.PI d.
Если аргумент имеет любой другой тип:
.RS
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errcode\*P значение
\*(CWYDB_ERR_WRONGARGS\*P.
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errmessage\*P значение
\*(CW"Argument [argnum] has wrong type."\*P, где \*(CW[argnum]\*P \*-
где номер этого аргумента.
.RE
.
.RE
.PI 4.
Если пользователем PHP был передан хотя бы один аргумент \*(CWkeys\*P,
заменить символ \*Q\*(CW,\*P\*U, находящийся в конце строки \*(CWs\*P на
символ \*Q\*(CW)\*P\*U.
.RE
.sp 0.5
.PP
Остальные действия для данных функций, кроме \*(CWydb_gettyped\*P
практически идентичны:
.sp 0.5
.RS
.PI 1.
Объединить переданные пользователем арументы \*(CWvar\*P и произвольное
число аргументов \*(CWkeys\*P в строку \*(CWs\*P, как было описано выше.
.PI 2.
Сформировать запрос вызывающий в сопроцессе функцию с аналогичным
именем и содержащий строку \*(CWs\*P в качестве первого аргумента. Для
функций \*(CWydb_set\*P и \*(CWydb_order\*P запрос помимо этого  в
качестве второго аргумента, должен содержать переданные пользователем
PHP аргументы \*(CWval\*P и \*(CWdir\*P соответственно.
.PI 3.
С помощью функции \*(CWyp_writerequest\*P отправить сформированный
запрос сопроцессу. Если произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 4.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если при получении ответа произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_readresponse\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 5.
Для функций \*(CWydb_get\*P, \*(CWydb_data\*P и \*(CWydb_order\*P, если
поле \*(CWresult\*P не равно \*(CWNULL\*P, вернуть содержащеся в нём
значение пользователю PHP в виде строки. Для функции \*(CWydb_kill\*P в
этом случае вернуть \*(CWTrue\*P. Если же поле \*(CWresult\*P равно
\*(CWNULL\*P:
.RS
.PI \(bu
Поместить содержимое поля \*(CWerrcode\*P в глобальную переменную
\*(CWyp_errcode\*P.
.PI \(bu
Поместить содержимое поля \*(CWerrmessage\*P в глобальную переменную
\*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 6.
Вернуть \*(CWTrue\*P.
.RE
.sp 0.5
.PP
Функция \*(CWydb_gettyped\*P отличается от остальных. Во-первых, вместо
одноимённой себе функции она вызывает функцию \*(CWydb_get\*P.
Во-вторых, после получения ответа выполняется еще одно действие \*-
определение типа содержащегося в поле \*(CWresult\*P значения. Это
делается с помощью следующей функции интерпретатора PHP:
.sp 0.5
.LS
zend_uchar is_numeric_string(const char *str, size_t length,
	zend_long *lval, double *dval, int allow_errors);
.LE
.sp 0.5
, где \*(CWstr\*P \*- строка, содержащая значение, \*(CWlength\*P \*-
длина этой строки, \*(CWlval\*P \*- значение, возвращаемое в случае,
если строка \*(CWstr\*P содержит целое число, \*(CWdval\*P \*-
значение, возвращаемое в случае, если строка \*(CWstr\*P содержит
десятичную дробь, а \*(CWallow_error\*P \*- указывает, считать строку,
где число содержится только в её начале численной или нет (1 \*-
считать, 0 \*- не считать). Данная функция возвращает значение
\*(CWIS_LONG\*P, если \*(CWstr\*P содержит целое число или
\*(CWIS_DOUBLE\*P, если \*(CWstr\*P содержит десятичную дробь. Любое
другое возвращаемое значение указывает, что \*(CWstr\*P не содержит
числа и может быть представлено в PHP только строкой. 
.PP
Полностью алгоритм определения типа возвращаемого значения выглядит так:
.sp 0.5
.RS
.PI 1.
Если элемент \*(CWresult\*P ответа равен \*(CW"true"\*P
(независимо от регистра), вернуть \*(CWTrue\*P.
.PI 2.
Если элемент \*(CWresult\*P ответа равен \*(CW"false"\*P
(независимо от регистра), вернуть \*(CWFalse\*P.
.PI 3.
Вызвать \*(CWis_numeric_string\*P.
.PI 4.
Если возвращаемое значение функции \*(CWis_numeric_string\*P равно
\*(CWIS_LONG\*P, вернуть пользователю PHP целое число, полученное через
её третий аргумент.
.PI 5.
Если возвращаемое значение функции \*(CWis_numeric_string\*P равно
\*(CWIS_DOUBLE\*P, вернуть пользователю PHP число с плавающей точкой,
полученное через её четвёртый аргумент аргумент.
.PI 6.
Если возвращаемое значение функции \*(CWis_numeric_string\*P не равно
\*(CWIS_DOUBLE\*P или \*(CWIS_LONG\*P, вернуть его как строку.
.RE
.sp 0.5
.PP
Функции \*(CWydb_error\*P, \*(CWydb_strerror\*P и \*(CWydb_zsinfo\*P,
как уже упоминалось, возвращают полученную ранее информацию об ошибках. 
Работа функций \*(CWydb_error\*P и \*(CWydb_strerror\*P сводится к
возврату пользователю PHP значений глобальных переменных
\*(CWyp_errcode\*P и \*(CWyp_errmessage\*P соответственно. Переменная
\*(CWyp_errcode\*P возвращается как целое число, а \*(CWyp_errmessage\*P
\*- как строка.
.PP
Функция \*(CWydb_szinfo\*P, предназначенная для получения информации
об ошибке YottaDB, как и \*(CWydb_strerror\*P работает с глобальной
переменной \*(CWyp_errmessage\*P, однако она не просто возвращает её
значение, а разбирает его, предполагая синтаксис, описанный в [4], в
разделе \*QIntrinsic Special Variables\*U, в части, посвященной
описанию специальной внутренней переменной YottaDB
\*(CW\[u0024]ZSTATUS\*P, помещая искомые элементы сообщения в
соответствующие им возвращаемые значения. В случае, если значение
переменной \*(CWyp_errmessage\*P разобрать не удаётся, функция
возвращает \*(CWFalse\*P, иначе возвращает \*(CWTrue\*P.
.H "5. Сопроцесс для работы с базой данных"
.PP
Выше, при описании работы функции \*(CWydb_init\*P был упомянут основной
цикл сопроцесса, запускаемый после настройки неименованных каналов для
передачи запросов и ответов. По сути, в данный цикл и выполняет всю
работу в сопроцессе. Записать его можно так:
.sp 0.5
.RE
.PI
Выполнять в бесконечном цикле:
.RS
.PI 1.
С помощью функции \*(CWyp_readrequest\*P получить запрос из
интерпретатора PHP. Если при получении запроса произошла ошибка:
.RS
.PI \(bu
Сгенерировать ответ, где поле \*(CWerrcode\*P содержит код возврата
функции \*(CWyp_readrequest\*P, а поле \*(CWerrmessage\*P содержит
строку, полученную в результате вызова \*(CWyp_jrstrerror\*P.
.PI \(bu
Попытаться отправить этот ответ.
.PI \(bu
Завершить сопроцесс с ненулевым кодом возврата помощью функции
\*(CWexit\*P.
.RE
.PI 2.
Запустить в данном сопроцессе функцию, соответствующую значению,
содержащемуся в поле \*(CWmethod\*P структуры \*(CWyp_request\*P,
передав ей в качестве параметров аргументы, содеражащиеся в поле
\*(CWparam\*P этой структуры. Все запускаемые таким образом функции
имеют один интерфейс:
.sp 0.5
.LS
	void func(const char *arg1, const char *arg2, ...,
		struct yp_result *r);
.LE
.sp 0.5
, где \*(CWfunc\*P \*- имя запускаемой функции, \*(CWarg1\*P,
\*(CWarg2\*P, \*(CW...\*P \*- аргументы, содержащиеся в поле
\*(CWparam\*P структуры \*(CWyp_request\*P, а \*(CWr\*P \*- структура
\*(CWyp_result\*P, куда помещается результат выполнения фукции.
.PI 3.
С помощью функции \*(CWyp_writeresponse\*P отправить пользователю
ответ, содержащийся в структуре \*(CWresult\*P, которая была заполнена
вызванной функцией. Если при отправке ответа произошла ошибка, завершить
сопроцесс с ненулевым кодом возврата с помощью функции \*(CWexit\*P.
.PI 4.
Если только что вызванная функция \*- это \*(CWydb_finilize\*P,
завершить сопроцесс с нулевым кодом возврата с помощью функции
\*(CWexit\*P.
.RE
.sp 0.5
.PP
Все функции, за исключением \*(CWydb_init\*P и \*(CWydb_finilize\*P,
упомянутые в пункте 2 приведённого выше цикла, являются такими же
\*Qточками входа\*U, \*Qзаглушками\*U, как и функции, вызывающие их из
интерпретатора PHP. Однако в отличие от последних, они вызывают
процедуры в адресном пространстве своего же процесса. Вызываемые
процедуры являются являются процедурами MUMPS, выполняющими всю работу с
базой данных.
.PP
Вызов процедур MUMPS выполняется с помощью специального интерфейса,
предназначенного для вызовов YottaDB из Си и предоставляемого
разделяемой библиотекой \*(CWlibyottadb.so\*P (см. [4], раздел
\*QIntegrating External Routines\*P). Данный интерфейс определяет
несколько функций, из которых предполагается использовать только две \*-
\*(CWydb_ci\*P, для запуска процедур YottaDB, и \*(CWydb_zstatus\*P,
для получения сообщений об ошибках.
.PP
Функция \*(CWydb_ci\*P использует для своей работы два файла \*- первый
файл содержит вызываемые процедуры MUMPS, а второй файл представляет
собой \*Iтаблицу вызовов\*P (\*Icall-in table\*P), позволяющую связать
процедуры MUMPS с языком Си. Файл с процедурами MUMPS, используемыми в
данном расширении приведён в приложении 1 (\*(CWydbphp.m\*P), а
соответствующая этим процедурам таблица вызовов приведена в приложении
2 (\*(CWydbphp.ci\*P).
.PP
Функция \*(CWydb_zstatus\*P, как уже упоминалось, используется для
получения сообщения об ошибке, если она произошла. Эта функция
записывает сообщение, содержащееся в специальной внутренней переменной
YottaDB \*(CW\[u0024]ZSTATUS\*P ([4], раздел \*QIntrinsic Special
Variables\*U) в переданную ей в качестве аргумента строку. Данное
сообщение в дальнейшем помещается в поле \*(CWerrmessage\*P ответа,
отправляемого обратно интерпретатору PHP.
.PP
Как упоминалось выше, функции \*(CWydb_init\*P и \*(CWydb_finilize\*P
\*- единственные вызываемые в сопроцессе функции, не являющиеся
\*Qточками входа\*U для процедур MUMPS. Задача этих функций \*-
инициализация YottaDB в сопроцессе и завершение работы сопроцесса.
.PP
Так как в YottaDB все первоначальные настройки выполняются с помощью
переменных окружения, то и работа \*(CWydb_init\*P сводится к настройке
окружения сопроцесса. Выглядит это так:
.sp 0.5
.RS
.PI 1.
Задать переменную окружения \*(CWgtmroutines\*P таким образом, чтобы она
содержала путь к директории, где лежит файл \*(CWydbphp.m\*P.
.PI 2.
Задать переменную окружения \*(CWGTMCI\*P таким образом, чтобы она
содержала путь к файлу \*(CWydbphp.ci\*P.
.PI 3.
Для каждого переданного в запросе аргумента: 
.RS
.PI a.
Если данный аргумент задаёт переменную окружения \*(CWgtmroutines\*P,
добавить пути, указанные в аргументе к тому пути, что уже задан в данной
переменной окружения.
.PI b.
Если данный аргумент задаёт переменную окружения \*(CWGTMCI\*P:
.RS
.PI \(bu
Поместить в поле \*(CWerrcode\*P ответа значение \*(CWYP_ERR_ENV\*P
.PI \(bu
Поместить в поле \*(CWerrmesssage\*P ответа значение
\*(CW"Enviroment variable GTMCI cannot be set by user"\*P.
.RE
.PI c.
Если данный аргумент задаёт любую другую переменную окружения,
предназначенную для настройки YottaDB, задать переменной окружения
указанное значение.
.PI d.
Если данный аргумент задаёт переменную окружения, не имеющую отношения к
настройке YottaDB:
.RS
.PI \(bu
Поместить в поле \*(CWerrcode\*P ответа значение \*(CWYP_ERR_ENV\*P
.PI \(bu
Поместить в поле \*(CWerrmesssage\*P ответа значение
\*(CW"Enviroment variable [envname] is not used by YottaDB"\*P,
где \*(CW[envname]\*P \*- имя задаваемой данным аргументом переменной
окружения.
.RE
.RE
.RE
.sp 0.5
.PP
Функция \*(CWydb_finilize\*P не выполняет никаких действий ни с базой
данных, ни с сопроцессом. Вызов данной функции является сигналом для
сопроцесса, указывающим ему, что необходимо завершить свою работу.
Данный сигнал, как было показано выше, обрабатывается основным циклом
сопроцесса, поэтому все, что делает функция \*(CWydb_finilize\*P \*-
это задает поле \*(CWresult\*P ответа, помещая в него пустую строку.
.PP
Остальные функции выглядят одинаково и запускают соответствующую им
процедуру MUMPS с помощью \*(CWydb_ci\*P:
.sp 0.5
.RS
.PI
С помощью \*(CWydb_ci\*P запустить процедуру MUMPS \*(CW[funcname]\*P,
передав ей имеющиеся в запросе аргументы, где \*(CW[funcname]\*P \*-
имя данной функции. Если \*(CWydb_ci\*P вернула отличный от нуля код:
.RS
.PI \(bu
Поместить код возврата \*(CWydb_ci\*P в поле \*(CWerrcode\*P ответа.
.PI \(bu
Поместить сообщение об ошибке, полученное с помощью вызова функции
\*(CWydb_zstatus\*P в поле \*(CWerrmessage\*P ответа.
.RE
.RE
.sp 0.5
.H "Приложение 1. ydbphp.m"
.LS
ydbget(var)
	quit @var
ydbset(var, val)
	set @var=val
	quit
ydbkill(var)
	kill @var
	quit
ydbdata(var)
	quit \[u0024]data(@var)
ydborder(var)
	quit \[u0024]order(@var)
.LE
.
.H "Приложение 2. ydbphp.ci"
.LS
ydb_get : gtm_char_t *ydbget^ydbphp(I:gtm_char_t *)
ydb_set : void ydbset^ydbphp(I:gtm_char_t *)
ydb_kill : void ydbkill^ydbphp(I:gtm_char_t *)
ydb_data : gtm_char_t *ydbdata^ydbphp(I:gtm_char_t *)
ydb_order : gtm_char_t *ydborder^ydbphp(I:gtm_char_t *)
.LE
.
.H "Ссылки"
.RS
.PI 1.
\*(CWhttps://www.jsonrpc.org/specification\*P \*- JSON-RPC 2.0
Specification.
.PI 2.
\*(CWhttps://www.json.org/json-ru.html\*P \*- JSON
.PI 3.
\*(CWhttps://docs.yottadb.com/MessageRecovery\*P \*- Messages and Recovery Procedures documentation
.PI 4.
\*(CWhttps://docs.yottadb.com/ProgrammersGuide\*P \*- Programmer's Guide documentation
.PI 5.
\*(CWhttp://www.phpinternalsbook.com\*P \*- PHP Internals Book
.RE
.
.H "Соображения"
.RS
.PI \(bu
Объединение трех разных диапазонов кодов ошибок в один, наверное не
очень хорошая идея. Может быть, стоит сделать как-то по другому.
.PI \(bu
Неименованные каналы не единственный вариант сообщения процессов.
Возможно стоит рассмотреть другие варианты.
.PI \(bu
Функция \*(CWydb_gettyped\*P использует плохо документированную
функцию PHP. Но другой пока я не нашел.
.PI \(bu
Возможно стоит добавить для функции \*(CWydb_gettyped\*P возможность
выгружать из базы узел вместо с дочерними узлами, помещаяя все в
ассоциативный массив. JSON как раз позволит это реализовать. Для
значения самое узла можно выделить какое-нибудь специальное значение.
.PI \(bu
Я не стал подробно описывать JSON-парсер. Возможно стоит это сделать в
отдельном документе. У меня есть прототип на \*(CWAWK\*P от другой
задачи, возможно это хорошая стартовая точка.
.PI
Также нет описания разбора перменной \*(CW\[u0024]ZSTATUS\*P. Однако, я
думаю, тут можно обойтись без полноценного парсера.
.PI \(bu
Я возлагаю почти всю обработку ошибок на саму базу данных. Надо будет
убедится, что она выдаёт все необходимые ошибки. Пока мне кажется, что
всё слишком красиво. Над кодом, выполняемым в MUMPS надо подумать.
.PI \(bu
Скорее всего еще понадобится реализация блокировок. Но она, мне кажется,
не будет отличаться от других функций.
.RE
