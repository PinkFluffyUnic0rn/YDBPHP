.
.
.ds Q \(Fo
.ds U \(Fc
.ds - \(em
.ds HSPACE1 3v;1.8v;0.5v;0v
.de H
.sp 3.0
.ps +7
.vs +7
.ft B
\\$1
.ft
.ps -7
.vs -7
.sp 1.0
..
.
.de NDFG
.KF
.sp 1.0v
.PSPIC \\$1 \\$2
.sp 0.25v
.ps -1
.vs -1
.ce 100
.nr NDARGN 3 0
.while (\\n[NDARGN] <= \\n[.$]) \{\
\\$\\n[NDARGN]
.nr NDARGN +1
.\}
.ce 0
.ps +1
.vs +1
.sp 1.0v
.KE
..
.
.de LS
.KS
.nf
.in \n[PI]u
.CW
..
.
.de LE
.KE
..
.
.char \[one] \s-2\v'-0.3m'1\v'+0.3m'\s+2
.
.
.ps +10
.vs +10
.ft B
.ce 2
Расширение PHP для работы с YottaDB
Проект реализации
.ft
.vs -10
.ps -10
.sp 2.5
.PP
Данный документ является описанием предполагаемой реализации расширения
языка PHP, предназначенного для работы с СУБД \*PYottaDB\*P. Реализация
базируется на описанном ранее программном интерфейсе для данного
расширения, который был приведён в виде отдельного документа.
.
.
.H "1. Общая структура расширения"
.PP
Предполагается, что код данного расширения будет выполняться в двух
отдельных процессах: часть кода будет выполняться в процессе
интерпретатора PHP, а часть \*- в дополнительном сопроцессе. Это нужно,
чтобы избежать конфликта, возникающего из-за того, что PHP и YottaDB
могут назначать разные обработчики одним и тем же сигналам. Также это
позволяет избежать определения \*Qчужих\*U переменных окружения в
адресном пространстве интерпретатора PHP.
.PP
Код, выполняемый в интерпретаторе PHP, в большинстве случаев, является
\*Qзаглушкой\*U \*- его задача подготовить аргументы, переданные
пользователем, и сформировать на их основе запрос, который будет
отправлен сопроцессу, затем, дождаться от сопроцесса ответа и вернуть
пользователю полученый в этом ответе результат.
.PP
Сопроцесс выполняет всю работу с базой данных. Получив запрос, он
определяет, какое именно действие необходимо выполнить, затем выполняет
вызов процедуры MUMPS, соответствующей этому действию и возвращает
ответ, поместив в него возвращаемое значение процедуры, если оно
имеется.
.PP
Взаимодействие кода расширения, находяшегося в интерпретаторе PHP, и
работающего с базой данных сопроцесса будет выполняться с помощью
протокола \*IJSON-RPC\*P [1]. Данные между процессами будут передаваться
через неименованые каналы в виде текста, без какого либо шифрования и
сжатия. 
.H "2. Протокол передачи данных пежду процессами"
.PP
Протокол JSON-RPC является текстовым протоколом, используемым для
удалённого вызова процедур, т.е. вызова процедур в другом адресном
пространстве. В данном случае выполняется вызов процедур (функций),
находящихся в адресном пространстве сопроцесса, из интерпретатора PHP.
.PP
Удалённый вызов процедуры происходит следующим образом:
.sp 0.5
.RS
.PI \(bu
Вызывающая сторона генерирует запрос, указывающий функцию, которую
необходимо вызвать. Также этот запрос содержит аргументы для этой
функции, если они имеются.
.PI \(bu
Получив запрос, выполняющая сторона (удалённый процесс или компьютер)
запускает указанную в запросе функцию и, если требуется, передаёт ей
аргументы, содержащиеся в запросе.
.PI \(bu
После завершения работы запущеной функции, выполняющая сторона
генерирует ответ, содержащий результат выполнения функции или сообщение
об ошибке, если она произошла.
.PI \(bu
Получив ответ, вызывающая сторона извлекает из него результат выполнения
функции или ошибку и продолжает свою работу.
.RE
.sp 0.5
Это можно изобразить, как показано на схеме (рис. 1), где \*IPHP\*P \*-
интерпретатор PHP, \*Icoprocess\*P \*- сопроцесс, \*Iprocedure\*P \*-
вызываемая процедура, \*Irequest\*P и \*Iresponse\*P \*- вызов удалённой
процедуры и ответ на неё, а \*Iarguments\*P и \*Ireturn value\*P \*-
аргументы и возвращаемое значение процедуры.
.NDFG rpcscheme.eps 30m "Рис. 1. Схема удалённого вызова процедуры."
.PP
В данном протоколе, как ясно из названия, используется формат JSON.
Описание этого формата можно найти в [2]. Запрос в JSON-RPC будет
выглядеть следующим образом:
.sp 0.5
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"method" : method,
	"params": [param1, param2, ...]
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, \*(CWmethod\*P \*-
строка, содержащая имя вызываемой процедуры, а
\*(CWparam1, param2, ...\*P \*- аргументы, передаваемые вызываемой
процедуре, если они имеются. Несмотря на то, что спецификация
протокола позволяет использовать в качестве аргументов как числа, так и
строки, в данном расширении предполагается представлять аргументы
исключительно строками. Помимо этого спецификация допускает, что в
качестве элемента \*(CWparams\*P может не массив, а объект, однако, в
данном расширении элемент \*(CWparams\*P всегда является массивом.
.PP
Ответ, если удалённая процедура была выполнена без ошибок, выглядит так:
.sp 0.5
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"result": result,
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, результат вызова которого
содержит этот ответ, а \*(CWresult\*P \*- результат вызова. Как и в
случае с аргументами, несмотря на то, что спецификация не ограничивает
тип этого элемента, в данном расширении предполагается использовать
только строки.
.PP
Ответ, если при вызове удалённой процедуры произошла ошибка, выглядит
так:
.LS
{
	"jsonrpc": "2.0",
	"id": id,
	"error": {
		"code": errorcode,
		"message": errormessage
	}
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, при вызове которого
произошла ошибка, \*(CWerrorcode\*P \*- числовой код ошибки,
\*(CWerrormessage\*P \*- строка, содержащая текстовое описание ошибки.
Источником ошибки может быть либо сам запрос или ответ, либо база
данных, либо операционная система. В случае ошибки в запросе
спецификацией JSON-RPC предусмотрены следующие коды ошибок:
.sp 1.0
.TS
allbox, center, expand;
c l l.
Код	Сообщение	Значение
-32700	Parse error	Ошибка при разборе JSON-запроса или JSON-ответа.
-32600	Invalid Request	T{
Отправленное JSON-сообщение не является корректным запросом.
T}
-32601	Method not found	Метод не найден или не доступен
-32602	Invalid params	Неверные параметры
-32603	Internal error	Внутренная ошибка JSON-RPC
-32000 \(en -32099	Server error	T{
Зарезервированы под определяемые реализацией ошибки сервера.
T}
.TE
.sp 1.0
.PP
В случае, когда ошибка произошла при работе с базой данных, возвращается
один из кодов ошибок, определенных в [3], в подразделе
\*QZMessage Codes\*U раздела \*QError Message Quick Reference\*U. Также
код ошибки YottaDB можно отличить от других с помощью констант
\*(CWYDB_MIN_YDBERR\*P  и \*(CWYDB_MAX_YDBERR\*P, определённых в файле
заголовков \*(CWlibyottadb.h\*P и указывающих нижнюю и верхнюю границы
диапазона кодов ошибок, используемых в YottaDB. Любые другие ошибки
следует считать ошибками, исходящими от операционной системы.
.PP
Также стоит отметить, что спецификация протокола позволяет использовать
в качестве идентификаторов запросов как целые числа, так и строки,
однако в данном расширении предполагается только использование целых
чисел.
.
.H "3. Обработка запросов и ответов"
.PP
Для чтения запросов и ответов предполагается использовать рекурсивный
парсер. Благодаря простому синтаксису JSON, такой парсер, даже будучи
написанным на C, получится достаточно компактным. Парсер будет разбирать
запросы и ответы, помещая их в соответствующие им структуры C.
.PP
Чтобы упростить разделение получаемых сообщений, а также чтобы снизить
количество выполняемых компьютером обращений к памяти и вычислений,
предполагается объединить чтение и разбор JSON-сообщения в одну функцию.
Текстовые данные будут читаться из неименованного канала \*Qна ходу\*U
разбираясь парсером. Как только будет получен полноценный JSON-объект,
функция будет завершаться и возвращать результат.
.PP
Формирование и отправку JSON-сообщения, также предполагается объединить
в одну функцию. Эта функция будет принимать структуру Си, описывающую
запрос или ответ и формировать на её основе JSON-сообщение, сразу
записывая это сообщение в неименованный канал.
.PP
Ошибки, которые могут происходить при отправке или получении запросов и
ответов могут быть связаны либо с передачей данных, либо с протоколом
передачи данных. В первом случае коды ошибок определяются стандартной
библиотекой Си, а сообщения об ошибках аналогичны сообщениям, получаемым
при вызове функции стандартной библиотеки Си \*(CWstrerror\*P. Во втором
случае коды ошибок определяются перечислением
.sp 0.5
.LS
enum YP_JRERROR {
	YP_ERR_JRPARSE = -32700
	YP_ERR_JRINVALREQ = -32600
	YP_ERR_JRINVALRES = -32001
	YP_ERR_JRREQSTRUCT = -32002
	YP_ERR_JRRESSTRUCT = -32003
}
.LE
.sp 0.5
и имеют следующие значения:
.sp 0.5
.RS
.PI
\*(CWYP_ERR_JRPARSE\*P \*- получен некорректный JSON-объект.
.PI
\*(CWYP_ERR_JRINVALREQ\*P \*- получен некорректный запрос.
.PI
\*(CWYP_ERR_JRINVALRES\*P \*- получен некорректный ответ.
.PI
\*(CWYP_ERR_JRREQSTRUCT\*P \*- структура, содержащая запрос,
некорректна.
.PI
\*(CWYP_ERR_JRRESSTRUCT\*P \*- структура, содержащая ответ, некорректна.
.RE
.sp 0.5
.PP
Данные коды ошибок организованны таким образом, чтобы соответствовать
кодам ошибок JSON-RPC, не пересекаясь диапазоном значений с кодами
ошибок стандартной библиотеки Си и кодами ошибок YottaDB. Текстовое
сообщение, соответствующее последней полученной при отправке или
получении запросов и ответов ошибки можно получить с помощью функции
.sp 0.5
.LS
char *yp_jrstrerror();
.LE
.sp 0.5
, возвращающей указатель на строку, содержающую это описание. Эту строку
нельзя модифицировать.
.PP
Для представления запросов в Си предполагается использовать следующую
структуру:
.sp 0.5
.LS
struct yp_request {
	int id;
	enum METHOD method;
	int paramcount;
	char **param;
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, \*(CWmethod\*P \*- значение
из перечисления \*(CWYP_METHOD\*P, указывающее, какую функцию необходимо
вызвать, \*(CWparamcount\*P \*- количество аргументов, передаваемых
вызываемой функции, а \*(CWparam\*P \*- набор строк, каждая из которых
содержит значение одного из этих аргументов. Перечисление
\*(CWYP_METHOD\*P предлагается определить следующим образом, при
необходимости добавляя в него новые значения:
.sp 0.5
.LS
enum YP_METHOD {
	YP_INIT,
	YP_FINILIZE,
	YP_GET,
	YP_SET,
	YP_KILL,
	YP_DATA,
	YP_ORDER
}
.LE
.sp 0.5
.PP
В данную структуру будут помещаться все полученные и разобранные
парсером ответы. Эта же структура будет заполнятся для формирования
и отправки JSON-сообщений, содержащих ответы.
.PP
Ответы в Си предполагается представлять следующей структурой:
.sp 0.5
.LS
struct yp_response {
	int id;
	char *result;
	int errcode;
	char *errmessage;
}
.LE
.sp 0.5
, где \*(CWid\*P \*- идентификатор запроса, результат вызова которого
содержит этот ответ, \*(CWresult\*P \*- строка, содержащая результат
вызова запроса, \*(CWerrcode\*P \*- код ошибки, \*(CWerrmessage\*P \*-
текстовое сообщение об ошибке. Отличить ответ с результатом успешного
выполнения функции от сообщения об ошибке можно по элементу
\*(CWresult\*P \*- если его значение равно \*(CWNULL\*P, значит ответ
является сообщением об ошибке, в любом другом случае выполнение было
успешным. Как и в случае с запросами эта структура будет использоваться
как для получения ответов, так и для их отправки.
.PP
Функция для чтения запросов имеет следующий заголовок:
.sp 0.5
.LS
int yp_readrequest(struct yp_request *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- указатель на структуру \*(CWyp_request\*P, куда
следует поместить прочитанный запрос. Помимо ошибок стандартной
библиотеки Си, данная функция может вернуть ошибки с кодами
\*(CWYP_JRPARSE\*P и \*(CWYP_ERR_JRINVALREQ\*P.
.PP
Заголовок функции для чтения ответов выглядит так:
.sp 0.5
.LS
int yp_readresponse(struct yp_response *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- указатель на структуру \*(CWyp_response\*P, куда
будет помещен прочитанный ответ. Помимо ошибок стандартной библиотеки
Си, данная функция может вернуть ошибки с кодами \*(CWYP_ERR_JRPARSE\*P
и \*(CWYP_ERR_JRINVALRES\*P.
.PP
Для генерации и отправки запроса будет использоваться функция с
заголовком
.sp 0.5
.LS
int yp_writerequest(struct yp_request *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- структура \*(CWyp_request\*P, содержащая запрос,
для которого нужно сгенерировать и отправить JSON-сообщение. Помимо
ошибок стандартной библиотеки Си, данная функция может вернуть ошибку с
кодом \*(CWJR_ERR_REQSTRUCT\*P.
.PP
Отправку ответов предполагается осуществлять функцией 
.sp 0.5
.LS
int yp_writeresponse(struct yp_response *r);
.LE
.sp 0.5
, где \*(CWr\*P \*- структура \*(CWyp_response\*P, содержащая ответ,
который нужно сгенерировать и отправить. Помимо ошибок стандартной
библиотеки Си, данная функция может вернуть ошибку с кодом
\*(CWJR_ERR_RESSTRUCT\*P.
.H "4. Работа с запросами в PHP расширении"
.PP
Как уже было написано выше, большинство функций данного расширения,
исполняющихся в интерпретаторе PHP, являются \*Qзаглушками\*U,
формирующими запрос на основе переданных им аргументов и возвращающие
пользователю данные из полученного ответа.
.PP
Исключением являются функции \*Iфункции-ловушки\*P (hooks)
\*(CWRINIT\*P и \*(CWRSHUTDOWN\*P, вызываемые пользователем PHP функции
\*(CWydb_init\*P и \*(CWydb_shutdown\*P, а также функции
\*(CWydb_error\*P, \*(CWydb_strerror\*P и \*(CWydb_szinfo\*P.
.PP
Функция \*(CWRINIT\*P используется для инициализации глобальной
переменной \*(CWyp_initilized\*P, указывающей, был ли создан
сопроцесс, предназначенный для работы с базой данных. Функция
\*(CWRINIT\*P вызывается без участия пользователя перед началом
обработки очередного CGI-запроса (см. [5], подраздел
\*QLearning the PHP lifecycle\*U раздела \*QExtensions design\*U) и
присваивает глобальной переменной \*(CWyp_initilized\*P значение
\*(CW0\*P.
.PP
Функция \*(CWydb_init\*P в процессе интерпретатора  отвечает за
инициализацию сопроцесса. Выглядит это так:
.sp 0.5
.RS
.PI 1.
Если глобальная переменная \*(CWyp_initilized\*P равна \*(CW1\*P,
вернуть \*(CWTrue\*P.
.PI 2.
Создать два неименованных канала с помощью системного вызова
\*(CWpipe\*P \*- один для передачи запросов, другой для передачи
ответов. В случае ошибки:
.RS
.PI \(bu
Поместить значение глобальной переменной
\*(CWerrno\*P в глобальную переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова фукнции
\*(CWstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 3.
Запустить сопроцесс с помощью системного вызова \*(CWfork\*P. В случае
ошибки:
.RS
.PI \(bu
Поместить значение глобальной переменной \*(CWerrno\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова фукнции
\*(CWstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 4.
В сопроцессе:
.RS
.PI a.
Закрыть конец для записи в неименованном канале, предназначенном для
передачи запросов.
.PI b.
Закрыть конец для чтения в неименованном канале, предназначенном для
передачи ответов.
.PI c.
Запустить основной цикл сопроцесса (будет описан в разделе 4).
.RE
.PI 5.
В интерпретаторе PHP:
.RS
.PI a.
Закрыть конец для чтения в неименованном канале, предназначенном для
передачи запросов.
.PI b.
Закрыть конец для записи в неименованном канале, предназначенном для
передачи ответов.
.RE
.PI 6.
Сформировать запрос для вызова в сопроцессе функции \*(CWydb_init\*P
(которая будет описана в разделе 5 данного документа) c аргументами,
задающими переменные окружения, которые были переданы пользователем
PHP в функцию \*(CWydb_init\*P в интерпретаторе.
.PI 7.
С помощью функции \*(CWyp_writerequest\*P отправить сформированный
запрос сопроцессу. Если произошла ошибка:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 8.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если данная функция завершилась с ошибкой:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_readresponse\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 9.
Если поле \*(CWresult\*P, полученного ответа равно \*(CWNULL\*P:
.RS
.PI \(bu
Закрыть неименованные каналы для передачи данных.
.PI \(bu
Получить код завершения сопроцесса с помощью функции \*(CWwaitpid\*P.
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 10
Присвоить переменной \*(CWyp_initilized\*P  значение \*(CW1\*P.
.PI 11
Вернуть \*(CWTrue\*P.
.RE
.sp 0.5
.PP
Функция \*(CWRSHUTDOWN\*P в процессе интерпретатора выполняет
действия, необходимые для завершения работы сопроцесса и вызывается
после окончания работы с очередным CGI-запросом (см. [5], подраздел
\*QLearning the PHP lifecycle\*U раздела \*QExtensions design\*U).
Выполняемые ей действия можно записать так:
.sp 0.5
.RS
.PI 1.
Если глобальная переменная \*(CWyp_initilized\*P равна \*(CW0\*P,
вернуть \*(CWSUCCESS\*P.
.PI 2.
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW0\*P.
.PI 3.
С помощью функции \*(CWyp_writerequest\*P отправить запрос для вызова в
сопроцессе функции \*(CWydb_finilize\*P (будет описана в разделе 4
данного документа). Если произошла ошибка:
.RS
.PI \(bu
Используя функцию \*(CWphp_err_docref\*P, вывести предупреждение,
содержащее строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.PI \(bu
Перейти к пункту 5.
.RE
.PI 4.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если при получении ответа произошла ошибка:
.RS
.PI \(bu
Используя функцию \*(CWphp_err_docref\*P, вывести предупреждение,
содержащее строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.PI \(bu
Перейти к пункту 5.
.RE
.PI 5.
Если поле \*(CWresult\*P полученного ответа равно \*(CWNULL\*P:
.RS
.PI \(bu
Вывести содержимое поля \*(CWerrmessage\*P с помощью фукнции
\*(CWphp_error_docref\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.RE
.PI 6.
Закрыть неименованные каналы для передачи данных.
.PI 7.
Получить код завершения сопроцесса с помощью функции \*(CWwait\*P. Если
код не равен нулю или его не удалось получить:
.RS
.PI \(bu
Вывести предупреждение \*(CW"Coprocess ended abnormaby."\*P с помощью
функции \*(CWphp_error_docref\*P.
.PI \(bu
Присвоить локальной переменной \*(CWiserror\*P значение \*(CW1\*P.
.RE
.PI 8.
Присвоить глобальной переменной \*(CWydb_initilized\*P значение
\*(CW0\*P.
.PI 9.
Если значение переменной \*(CWiserror\*P равно \*(CW0\*P, вернуть
\*(CWSUCCESS\*P, иначе вернуть \*(CWFAILURE\*P.
.RE
.sp 0.5
.PP
Функция \*(CWydb_finilize\*P предназначена для завершения сопроцесса
пользователем PHP \*Qвручную\*U и выполняет действия аналогичные тем,
что выполняются функцией \*(CWRSHUTDOWN\*P, от которой она отличается
только обработкой ошибок. В случае ошибки данная функция возвращает
\*(CWFalse\*P, при этом помещая код ошибки в глобальную переменную
\*(CWyp_errcode\*P\*P, а сообщение об ошибке \*- в глобальную переменную
\*(CWyp_errmessage\*P. При успешном выполнении возвращается
\*(CWTrue\*P. 
.PP
Функции \*(CWydb_set\*P, \*(CWydb_get\*P, \*(CWydb_gettyped\*P,
\*(CWydb_kill\*P, \*(CWydb_data\*P и \*(CWydb_order\*P, как уже
упоминалось, формируют запрос, содержащий переданные им аргументы,
отправляют его, дожидаются ответа и возвращают результат выполнения
функции в сопроцессе, содержащийся в этом ответе.
.PP
Первые аргументы приведённых выше функций \*- \*(CWvar\*P и произвольное
число аргументов \*(CWkeys\*P (см. описание программного интерфейса)
обрабатываются одинаковым образом. Эти аргументы преобразуются в одну
цельную строку, всегда помещаемую в запрос в качестве первого аргумента
и указывающую переменную или элемент массива, над которым нужно
выполнить действие.  Данное преобразование выглядит так:
.sp 0.5
.RS
.PI 1.
Инициализировать строку \*(CWs\*P значением переданного пользователем
PHP аргумента \*(CWvar\*P.
.PI 2.
Если пользователем PHP был передан хотя бы один аргумент \*(CWkeys\*P,
добавить к строке \*(CWs\*P символ \*Q\*(CW(\*P\*U.
.PI 3.
Для каждого переданного пользователем PHP аргумента \*(CWkeys\*P, с
первого такого аргумента по последний:
.RS
.PI a.
Если этот аргумент является строкой, присоединить его к \*(CWs\*P,
дополнив символом \*Q\*(CW,\*P\*U.
.PI b.
Если этот аргумент является числом, преобразовать его в строку и
присоединить к \*(CWs\*P, дополнив символом \*Q\*(CW,\*P\*U.
.PI c.
Если этот аргумент является массивом PHP с целочисленными ключами, то
для каждого его элемента массива, с первого по последний:
.RS
.PI \(bu.
Если данный элемент является строкой, присоединить его к \*(CWs\*P,
дополнив символом \*Q\*(CW,\*P\*U.
.PI \(bu.
Если данный элемент является числом, приобразовать его в строку и
присоединить к \*(CWs\*P, дополнив символом \*Q\*(CW,\*P\*U.
.RE
.PI d.
Если аргумент имеет любой другой тип:
.RS
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errcode\*P значение
\*(CWYDB_ERR_WRONGARGS\*P.
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errmessage\*P значение
\*(CW"Argument [argnum] has wrong type."\*P, где \*(CW[argnum]\*P \*-
где номер этого аргумента.
.RE
.
.RE
.PI 4.
Если пользователем PHP был передан хотя бы один аргумент \*(CWkeys\*P,
заменить символ \*Q\*(CW,\*P\*U, находящийся в конце строки \*(CWs\*P на
символ \*Q\*(CW)\*P\*U.
.RE
.sp 0.5
.PP
Остальные действия для данных функций, кроме \*(CWydb_gettyped\*P
практически идентичны:
.sp 0.5
.RS
.PI 1.
Если глобальная переменная \*(CWyp_initilized\*P равна \*(CW0\*P:
.RS
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errcode\*P значение
\*(CWYDB_ERR_NOTINITILIZED\*P.
.PI \(bu
Присвоить глобальной переменной \*(CWydb_errmessage\*P значение
\*(CW"Coprocess wasn't initilized. You should run ydb_init() first."\*P.
.PI \(bu
Вернуть \*(CWfalse\*P.
.RE
.PI 1.
Объединить переданные пользователем арументы \*(CWvar\*P и произвольное
число аргументов \*(CWkeys\*P в строку \*(CWs\*P, как было описано выше.
.PI 2.
Сформировать запрос вызывающий в сопроцессе функцию с аналогичным
именем и содержащий строку \*(CWs\*P в качестве первого аргумента. Для
функций \*(CWydb_set\*P и \*(CWydb_order\*P запрос помимо этого  в
качестве второго аргумента, должен содержать переданные пользователем
PHP аргументы \*(CWval\*P и \*(CWdir\*P соответственно.
.PI 3.
С помощью функции \*(CWyp_writerequest\*P отправить сформированный
запрос сопроцессу. Если произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_writerequest\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 4.
Получить ответ от сопроцесса с помощью функции \*(CWyp_readresponse\*P.
Если при получении ответа произошла ошибка:
.RS
.PI \(bu
Поместить код возврата функции \*(CWyp_readresponse\*P в глобальную
переменную \*(CWyp_errcode\*P.
.PI \(bu
Скопировать строку, полученную в результате вызова функции
\*(CWyp_jrstrerror\*P в глобальную переменную \*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 5.
Для функций \*(CWydb_get\*P, \*(CWydb_data\*P и \*(CWydb_order\*P, если
поле \*(CWresult\*P не равно \*(CWNULL\*P, вернуть содержащеся в нём
значение пользователю PHP в виде строки. Для функции \*(CWydb_kill\*P в
этом случае вернуть \*(CWTrue\*P. Если же поле \*(CWresult\*P равно
\*(CWNULL\*P:
.RS
.PI \(bu
Поместить содержимое поля \*(CWerrcode\*P в глобальную переменную
\*(CWyp_errcode\*P.
.PI \(bu
Поместить содержимое поля \*(CWerrmessage\*P в глобальную переменную
\*(CWyp_errmessage\*P.
.PI \(bu
Вернуть \*(CWFalse\*P.
.RE
.PI 6.
Вернуть \*(CWTrue\*P.
.RE
.sp 0.5
.PP
Функция \*(CWydb_gettyped\*P отличается от остальных. Во-первых, вместо
одноимённой себе функции она вызывает функцию \*(CWydb_get\*P.
Во-вторых, после получения ответа выполняется еще одно действие \*-
определение типа содержащегося в поле \*(CWresult\*P значения. Это
делается с помощью следующей функции интерпретатора PHP:
.sp 0.5
.LS
zend_uchar is_numeric_string(const char *str, size_t length,
	zend_long *lval, double *dval, int allow_errors);
.LE
.sp 0.5
, где \*(CWstr\*P \*- строка, содержащая значение, \*(CWlength\*P \*-
длина этой строки, \*(CWlval\*P \*- значение, возвращаемое в случае,
если строка \*(CWstr\*P содержит целое число, \*(CWdval\*P \*-
значение, возвращаемое в случае, если строка \*(CWstr\*P содержит
десятичную дробь, а \*(CWallow_error\*P \*- указывает, считать строку,
где число содержится только в её начале численной или нет (1 \*-
считать, 0 \*- не считать). Данная функция возвращает значение
\*(CWIS_LONG\*P, если \*(CWstr\*P содержит целое число или
\*(CWIS_DOUBLE\*P, если \*(CWstr\*P содержит десятичную дробь. Любое
другое возвращаемое значение указывает, что \*(CWstr\*P не содержит
числа и может быть представлено в PHP только строкой. 
.PP
Полностью алгоритм определения типа возвращаемого значения выглядит так:
.sp 0.5
.RS
.PI 1.
Если элемент \*(CWresult\*P ответа равен \*(CW"true"\*P
(независимо от регистра), вернуть \*(CWTrue\*P.
.PI 2.
Если элемент \*(CWresult\*P ответа равен \*(CW"false"\*P
(независимо от регистра), вернуть \*(CWFalse\*P.
.PI 3.
Вызвать \*(CWis_numeric_string\*P.
.PI 4.
Если возвращаемое значение функции \*(CWis_numeric_string\*P равно
\*(CWIS_LONG\*P, вернуть пользователю PHP целое число, полученное через
её третий аргумент.
.PI 5.
Если возвращаемое значение функции \*(CWis_numeric_string\*P равно
\*(CWIS_DOUBLE\*P, вернуть пользователю PHP число с плавающей точкой,
полученное через её четвёртый аргумент аргумент.
.PI 6.
Если возвращаемое значение функции \*(CWis_numeric_string\*P не равно
\*(CWIS_DOUBLE\*P или \*(CWIS_LONG\*P, вернуть его как строку.
.RE
.sp 0.5
.PP
Функции \*(CWydb_error\*P, \*(CWydb_strerror\*P и \*(CWydb_zsinfo\*P,
возвращают полученную ранее информацию об ошибках.  Работа функций
\*(CWydb_error\*P и \*(CWydb_strerror\*P сводится к возврату
пользователю PHP значений глобальных переменных \*(CWyp_errcode\*P и
\*(CWyp_errmessage\*P соответственно. Переменная \*(CWyp_errcode\*P
возвращается как целое число, а \*(CWyp_errmessage\*P \*- как строка.
.PP
Функция \*(CWydb_szinfo\*P, предназначенная для получения информации
об ошибке YottaDB, как и \*(CWydb_strerror\*P работает с глобальной
переменной \*(CWyp_errmessage\*P, однако она не просто возвращает её
значение, а разбирает его, предполагая синтаксис, описанный в [4], в
разделе \*QIntrinsic Special Variables\*U, в части, посвященной
описанию специальной внутренней переменной YottaDB
\*(CW\[u0024]ZSTATUS\*P, помещая искомые элементы сообщения в
соответствующие им возвращаемые значения. В случае, если значение
переменной \*(CWyp_errmessage\*P разобрать не удаётся, функция
возвращает \*(CWFalse\*P, иначе возвращает \*(CWTrue\*P.
.PP
Описанные в данном разделе функции позволяют использовать данное
расширение как с интерпретатором в режиме обычного CGI, так и с
интерпретатором в режиме \*IFastCGI\*P. Однако в случае работы в режиме
FastCGI имеется ограничение \*- интерпретотор должен
обрабатывать CGI-запросы последовательно, не используя \*Iнити\*P
(threads). Это связано с тем с активным использованием глобальных
переменных, которые в случае разделения процесса на нити, могут
одновременно читаться и изменяться несколькими нитями, что рано или
поздно вызовет ошибку.
.PP
В приложении 1 приведен пример обработки запроса при работе
интерпретотора в режиме FastCGI. В случае, если интерпретатор работает
в режиме обычно CGI, обработка запроса будет выглядить аналогично, за
исключением того, что выполнение кода в функции \*(CWMSHUTDOWN\*P будет
избыточным.
.H "5. Сопроцесс для работы с базой данных"
.PP
Выше, при описании работы функции \*(CWydb_init\*P был упомянут основной
цикл сопроцесса, запускаемый после настройки неименованных каналов для
передачи запросов и ответов. По сути, в данный цикл и выполняет всю
работу в сопроцессе. Записать его можно так:
.sp 0.5
.RE
.PI
Выполнять в бесконечном цикле:
.RS
.PI 1.
С помощью функции \*(CWyp_readrequest\*P получить запрос из
интерпретатора PHP. Если при получении запроса произошла ошибка:
.RS
.PI \(bu
Сгенерировать ответ, где поле \*(CWerrcode\*P содержит код возврата
функции \*(CWyp_readrequest\*P, а поле \*(CWerrmessage\*P содержит
строку, полученную в результате вызова \*(CWyp_jrstrerror\*P.
.PI \(bu
Попытаться отправить этот ответ.
.PI \(bu
Завершить сопроцесс с ненулевым кодом возврата помощью функции
\*(CWexit\*P.
.RE
.PI 2.
Запустить в данном сопроцессе функцию, соответствующую значению,
содержащемуся в поле \*(CWmethod\*P структуры \*(CWyp_request\*P,
передав ей в качестве параметров аргументы, содеражащиеся в поле
\*(CWparam\*P этой структуры. Все запускаемые таким образом функции
имеют один интерфейс:
.sp 0.5
.LS
	void func(const char *arg1, const char *arg2, ...,
		struct yp_result *r);
.LE
.sp 0.5
, где \*(CWfunc\*P \*- имя запускаемой функции, \*(CWarg1\*P,
\*(CWarg2\*P, \*(CW...\*P \*- аргументы, содержащиеся в поле
\*(CWparam\*P структуры \*(CWyp_request\*P, а \*(CWr\*P \*- структура
\*(CWyp_result\*P, куда помещается результат выполнения фукции.
.PI 3.
С помощью функции \*(CWyp_writeresponse\*P отправить пользователю
ответ, содержащийся в структуре \*(CWresult\*P, которая была заполнена
вызванной функцией. Если при отправке ответа произошла ошибка, завершить
сопроцесс с ненулевым кодом возврата с помощью функции \*(CWexit\*P.
.PI 4.
Если только что вызванная функция \*- это \*(CWydb_finilize\*P,
завершить сопроцесс с нулевым кодом возврата с помощью функции
\*(CWexit\*P.
.RE
.sp 0.5
.PP
Все функции, за исключением \*(CWydb_init\*P и \*(CWydb_finilize\*P,
упомянутые в пункте 2 приведённого выше цикла, являются такими же
\*Qточками входа\*U, \*Qзаглушками\*U, как и функции, вызывающие их из
интерпретатора PHP. Однако в отличие от последних, они вызывают
процедуры в адресном пространстве своего же процесса. Вызываемые
процедуры являются являются процедурами MUMPS, выполняющими всю работу с
базой данных.
.PP
Вызов процедур MUMPS выполняется с помощью специального интерфейса,
предназначенного для вызовов YottaDB из Си и предоставляемого
разделяемой библиотекой \*(CWlibyottadb.so\*P (см. [4], раздел
\*QIntegrating External Routines\*P). Данный интерфейс определяет
несколько функций, из которых предполагается использовать только две \*-
\*(CWydb_ci\*P, для запуска процедур YottaDB, и \*(CWydb_zstatus\*P,
для получения сообщений об ошибках.
.PP
Функция \*(CWydb_ci\*P использует для своей работы два файла \*- первый
файл содержит вызываемые процедуры MUMPS, а второй файл представляет
собой \*Iтаблицу вызовов\*P (\*Icall-in table\*P), позволяющую связать
процедуры MUMPS с языком Си. Файл с процедурами MUMPS, используемыми в
данном расширении приведён в приложении 2 (\*(CWydbphp.m\*P), а
соответствующая этим процедурам таблица вызовов приведена в приложении
3 (\*(CWydbphp.ci\*P).
.PP
Функция \*(CWydb_zstatus\*P, как уже упоминалось, используется для
получения сообщения об ошибке, если она произошла. Эта функция
записывает сообщение, содержащееся в специальной внутренней переменной
YottaDB \*(CW\[u0024]ZSTATUS\*P ([4], раздел \*QIntrinsic Special
Variables\*U) в переданную ей в качестве аргумента строку. Данное
сообщение в дальнейшем помещается в поле \*(CWerrmessage\*P ответа,
отправляемого обратно интерпретатору PHP.
.PP
Как упоминалось выше, функции \*(CWydb_init\*P и \*(CWydb_finilize\*P
\*- единственные вызываемые в сопроцессе функции, не являющиеся
\*Qточками входа\*U для процедур MUMPS. Задача этих функций \*-
инициализация YottaDB в сопроцессе и завершение работы сопроцесса.
.PP
Так как в YottaDB все первоначальные настройки выполняются с помощью
переменных окружения, то и работа \*(CWydb_init\*P сводится к настройке
окружения сопроцесса. Выглядит это так:
.sp 0.5
.RS
.PI 1.
Задать переменную окружения \*(CWgtmroutines\*P таким образом, чтобы она
содержала путь к директории, где лежит файл \*(CWydbphp.m\*P.
.PI 2.
Задать переменную окружения \*(CWGTMCI\*P таким образом, чтобы она
содержала путь к файлу \*(CWydbphp.ci\*P.
.PI 3.
Для каждого переданного в запросе аргумента: 
.RS
.PI a.
Если данный аргумент задаёт переменную окружения \*(CWgtmroutines\*P,
добавить пути, указанные в аргументе к тому пути, что уже задан в данной
переменной окружения.
.PI b.
Если данный аргумент задаёт переменную окружения \*(CWGTMCI\*P:
.RS
.PI \(bu
Поместить в поле \*(CWerrcode\*P ответа значение \*(CWYP_ERR_ENV\*P
.PI \(bu
Поместить в поле \*(CWerrmesssage\*P ответа значение
\*(CW"Enviroment variable GTMCI cannot be set by user"\*P.
.RE
.PI c.
Если данный аргумент задаёт любую другую переменную окружения,
предназначенную для настройки YottaDB, задать переменной окружения
указанное значение.
.PI d.
Если данный аргумент задаёт переменную окружения, не имеющую отношения к
настройке YottaDB:
.RS
.PI \(bu
Поместить в поле \*(CWerrcode\*P ответа значение \*(CWYP_ERR_ENV\*P
.PI \(bu
Поместить в поле \*(CWerrmesssage\*P ответа значение
\*(CW"Enviroment variable [envname] is not used by YottaDB"\*P,
где \*(CW[envname]\*P \*- имя задаваемой данным аргументом переменной
окружения.
.RE
.RE
.RE
.sp 0.5
.PP
Функция \*(CWydb_finilize\*P не выполняет никаких действий ни с базой
данных, ни с сопроцессом. Вызов данной функции является сигналом для
сопроцесса, указывающим ему, что необходимо завершить свою работу.
Данный сигнал, как было показано выше, обрабатывается основным циклом
сопроцесса, поэтому все, что делает функция \*(CWydb_finilize\*P \*-
это задает поле \*(CWresult\*P ответа, помещая в него пустую строку.
.PP
Остальные функции выглядят одинаково и запускают соответствующую им
процедуру MUMPS с помощью \*(CWydb_ci\*P:
.sp 0.5
.RS
.PI
С помощью \*(CWydb_ci\*P запустить процедуру MUMPS \*(CW[funcname]\*P,
передав ей имеющиеся в запросе аргументы, где \*(CW[funcname]\*P \*-
имя данной функции. Если \*(CWydb_ci\*P вернула отличный от нуля код:
.RS
.PI \(bu
Поместить код возврата \*(CWydb_ci\*P в поле \*(CWerrcode\*P ответа.
.PI \(bu
Поместить сообщение об ошибке, полученное с помощью вызова функции
\*(CWydb_zstatus\*P в поле \*(CWerrmessage\*P ответа.
.RE
.RE
.sp 0.5
.H "Приложение 1. Пример обработки FastCGI-запроса."
.PP
В этом приложении приведён пример обработки на FastCGI-запроса в
следующем PHP-сценарии:
.sp 0.5
.LS
\[u0024]env = array(
	"gtm_dist=/usr/local/lib/yottadb/r128",
	"gtmgbldir=/home/evgeniy/.yottadb/g/yottadb.gld",
	"ydb_dir=/home/qwerty/.yottadb",
	"ydb_rel=r1.28_x86_64");

if (!ydb_init(\[u0024]env)) {
	error_log("Error occured: " . ydb_strerror(), 0);
	return 1;	
}

if (!ydb_set("^person", "Komi Republic", "Syktyvkar",
	1, "name", "Ivan")) {
	error_log("Error occured: " . ydb_strerror(), 0);
	return 1;	
}

if ((s = ydb_get("^person", "Komi Republic", "Syktyvkar",
	1, "name")) === FALSE) {
	error_log("Error occured: " . ydb_strerror(), 0);
	return 1;	
}

if ((s = ydb_get("^person", "Komi Republic", "Syktyvkar",
	1, "surname", "Ivan")) === FALSE) {
	error_log("Error occured: " . ydb_strerror(), 0);
	return 1;	
}

return 0;
.LE
.sp 0.5
.PP
Сначала, при получении CGI-запроса, запускается функция \*(CWRINIT\*P,
устанавливающая глобальную переменную \*(CWyp_initilized\*P в \*(CW0\*P.
.PP
После этого заполняется массив \*(CWenv\*P, который далее передаётся
функции \*(CWydb_init\*P в качестве аргумента. Данная функция создаёт
неименованные каналы и выполняет запуск сопроцесса, а затем формирует
запрос для вызова функции \*(CWydb_init\*P в сопроцессе. Для этого
сначала заполняется структура \*(CWyp_request\*P:
.sp 0.5
.PSPIC requeststruct1.eps 25m
.sp 0.5
Далее на основе этой структуры формируется JSON-запрос
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 1,
	"method" : "YDB_INIT",
	"params" : [
		"gtm_dist=/usr/local/lib/yottadb/r128",
		"gtmgbldir=/home/qwerty/.yottadb/g/yottadb.gld",
		"ydb_dir=/home/qwerty/.yottadb",
		"ydb_rel=r1.28_x86_64"
	]
}
.LE
.sp 0.5
, который отправляется сопроцессу. От сопроцесса приходит JSON-ответ
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 1,
	"result" : ""
}
.LE
.sp 0.5
, помещаемый в структуру
.sp 0.5
.PSPIC responsestruct1.eps 10m
.sp 0.5
После получения ответа функция \*(CWydb_init\*P возвращает \*(CWTrue\*P
и выполнение переходит к следующим командам.
.PP
При вызове \*(CWydb_set\*P из переданных пользователем аргументов
формируется структура \*(CWyp_request\*P следующего вида:
.sp 0.5
.PSPIC requeststruct2.eps 27m
.sp 0.5
На основе этой структуры формируется JSON-запрос
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 2,
	"method" : "YDB_SET",
	"params" : [
		"^person("Komi Republic","Syktyvkar",1,"Name")",
		"Ivan"
	]
}
.LE
.sp 0.5
, который отправляется сопроцессу. JSON-ответ, полученный от сопроцесса
выглядит следующим образом:
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 2,
	"result" : ""
}
.LE
.sp 0.5
Этот ответ помещается в структуру \*(CWyp_response\*P:
.sp 0.5
.PSPIC responsestruct2.eps 10m
.sp 0.5
Далее, так как поле \*(CWresult\*P этой структуры содержит пустую
строку, функция \*(CWydb_set\*P возвращает \*(CWTrue\*P.
.PP
Следующей вызывается функция \*(CWydb_get\*P, где сформированная из
переданных пользователем аргументов структура \*(CWyp_request\*P
выглядит следующим образом:
.sp 0.5
.PSPIC requeststruct3.eps 30m
.sp 0.5
На её основе формируется JSON-запрос
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 3,
	"method" : "YDB_GET",
	"params" : [
		"^person("Komi Republic","Syktyvkar",1,"Name")"
	]
}
.LE
.sp 0.5
, отправляемый сопроцессу. От сопроцесса приходит JSON-ответ
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 3,
	"result" : "Ivan"
}
.LE
.sp 0.5
, помещаемый в структуру \*(CWyp_response\*P:
.sp 0.5
.PSPIC responsestruct3.eps 12m
.sp 0.5
После этого, функция \*(CWydb_get\*P завершается и возвращает
пользователю значение поля \*(CWresult\*P этой струкуры \*- строку
\*(CW"Ivan"\*P.
.PP
Далее функция \*(CWydb_get\*P вызывается второй раз, но уже с другими
аргументами, что провоцирует ошибку, связанную с отсутсвием искомого
элемента в массиве MUMPS. В результате этой ошибки, от сопроцесса
приходит следующий JSON-ответ (переносы строки в элементе
\*(CW"message"\*P добавлены для удобства чтения и в реальном ответе
отсутствуют):
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 2,
	"error" : {
		"code" : 150372994,
		"message" : "150372994,ydbget+1^ydbphp,%YDB-E-GVUNDEF,
Global variable undefined:
^person(\\"Komi Republic\\",\\"Syktyvkar\\",1,\\"surname\\")"
	}
}
.LE
.sp 0.5
Этот ответ помещается в структуру \*(CWyp_response\*P:
.sp 0.5
.PSPIC responsestruct4.eps 27m
.sp 0.5
Из-за того, что была получена ошибка, значения полей \*(CWerrcode\*P и
\*(CWerrmessage\*P помещаются в глобальные переменные \*(CWyp_errcode\*P
и \*(CWyp_errmessage\*P, а затем функция \*(CWydb_get\*P завершается,
вернув значение \*(CWFalse\*P.
.PP
Следующей вызывается функция \*(CWydb_strerror\*P. Эта функция
возвращает значение переменной \*(CWyp_errmessage\*P в виде строки PHP.
Полученная строка отправляется в журнал ошибок, определенный
конфигурацией интерпретатора PHP, а затем обработка CGI-запроса
завершается с кодом \*(CW1\*P.
.PP
После завершения работы с CGI-запросом, запускается функция
\*(CWRSHUTDOWN\*P. Сначала данной функцией формируется структура
\*(CWyp_request\*P:
.sp 0.5
.PSPIC requeststruct5.eps 10m
.sp 0.5
, которая преобразуется в JSON-запрос
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 5,
	"method" : "YDB_FINILIZE",
}
.LE
.sp 0.5
, отправляемый сопроцессу. Ответ сопроцесса выглядит следующим образом:
.sp 0.5
.LS
{
	"jsonrpc" : "2.0",
	"id" : 5,
	"result" : ""
}
.LE
Этот ответ помещается в структуру \*(CWyp_response\*P:
.sp 0.5
.PSPIC responsestruct5.eps 10m
.sp 0.5
Далее закрываются неименованные каналы для передачи запросов и ответов,
а затем, с помощью вызова функции \*(CWwait\*P забирается код возврата
сопроцесса. Так как ошибок при завершении сопроцесса не произошло,
функция \*(CWMSHUTDOWN\*P возвращает значение \*(CWSUCCESS\*P и
интерпретатор PHP переходит к обработке следующего CGI-запроса.
.
.H "Приложение 2. ydbphp.m"
.LS
ydbget(var)
	quit @var
ydbset(var, val)
	set @var=val
	quit
ydbkill(var)
	kill @var
	quit
ydbdata(var)
	quit \[u0024]data(@var)
ydborder(var)
	quit \[u0024]order(@var)
.LE
.
.H "Приложение 3. ydbphp.ci"
.LS
ydb_get : gtm_char_t *ydbget^ydbphp(I:gtm_char_t *)
ydb_set : void ydbset^ydbphp(I:gtm_char_t *)
ydb_kill : void ydbkill^ydbphp(I:gtm_char_t *)
ydb_data : gtm_char_t *ydbdata^ydbphp(I:gtm_char_t *)
ydb_order : gtm_char_t *ydborder^ydbphp(I:gtm_char_t *)
.LE
.
.H "Ссылки"
.RS
.PI 1.
\*(CWhttps://www.jsonrpc.org/specification\*P \*- JSON-RPC 2.0
Specification.
.PI 2.
\*(CWhttps://www.json.org/json-ru.html\*P \*- JSON
.PI 3.
\*(CWhttps://docs.yottadb.com/MessageRecovery\*P \*- Messages and Recovery Procedures documentation
.PI 4.
\*(CWhttps://docs.yottadb.com/ProgrammersGuide\*P \*- Programmer's Guide documentation
.PI 5.
\*(CWhttp://www.phpinternalsbook.com\*P \*- PHP Internals Book
.RE
.
.H "Соображения"
.RS
.PI \(bu
Объединение трех разных диапазонов кодов ошибок в один, наверное не
очень хорошая идея. Может быть, стоит сделать как-то по другому.
.PI \(bu
Неименованные каналы не единственный вариант сообщения процессов.
Возможно стоит рассмотреть другие варианты.
.PI \(bu
Функция \*(CWydb_gettyped\*P использует плохо документированную
функцию PHP. Но другой пока я не нашел.
.PI \(bu
Возможно стоит добавить для функции \*(CWydb_gettyped\*P возможность
выгружать из базы узел вместо с дочерними узлами, помещаяя все в
ассоциативный массив. JSON как раз позволит это реализовать. Для
значения самое узла можно выделить какое-нибудь специальное значение.
.PI \(bu
Я не стал подробно описывать JSON-парсер. Возможно стоит это сделать в
отдельном документе. У меня есть прототип на \*(CWAWK\*P от другой
задачи, возможно это хорошая стартовая точка.
.PI
Также нет описания разбора перменной \*(CW\[u0024]ZSTATUS\*P. Однако, я
думаю, тут можно обойтись без полноценного парсера.
.PI \(bu
Я возлагаю почти всю обработку ошибок на саму базу данных. Надо будет
убедится, что она выдаёт все необходимые ошибки. Пока мне кажется, что
всё слишком красиво. Над кодом, выполняемым в MUMPS надо подумать.
.PI \(bu
Скорее всего еще понадобится реализация блокировок. Но она, мне кажется,
не будет отличаться от других функций.
.PI \(bu
В данный момент при использовании FastCGI, сопроцесс создаётся при
обработке каждого нового запроса. Возможно стоит рассмотреть вариант,
когда сопроцесс создаётся единожды, при запуске интерпретора. Однако
в этом случае придётся постоянно проверять и поддерживать целостность
окружения базы данных в сопроцессе, но возможно, это будет расходовать
еще больше ресурсов, чем удаление и создание нового процесса.
.PI \(bu
Теоретически, может получиться процессс-зомби, но в случае проблем с
передачей данных сопроцесс должен немедленно завершиться. Надо получше
изучить этот момент.
.RE
.
.H "Изменения"
.RS
.PI
Раздел 3:
.RS
.PI \(bu
В структуру \*(CWyp_request\*P добавлено поле \*(CWparamcount\*P.
.RE
.PI
Раздел 4:
.RS
.PI \(bu
Добавление описание функции \*(CWRINIT\*P.
.PI \(bu
Немного переделана функция \*(CWydb_init\*P и функции для работы с
базой данных.
.PI \(bu
Код функции \*(CWydb_finilize\*P теперь вызывается в функции
\*(CWRSHUTDOWN\*P.
.RE
Добавлено приложение с примером обработки FastCGI-запроса.
.RE
