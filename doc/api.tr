.
.
.ds Q \(Fo
.ds U \(Fc
.ds - \(em
.ds HSPACE1 3v;1.8v;0.5v;0v
.de H
.sp 3.0
.ps +7
.vs +7
.ft B
\\$1
.ft
.ps -7
.sp 1.0
..
.
.char \[one] \s-2\v'-0.3m'1\v'+0.3m'\s+2
.
.
.ps +10
.ft B
.ce 1
Расширение PHP для работы с YottaDB
.ft
.ps -10
.sp 2.5
.
.PP
Данное расширение предназначено для работы с переменными MUMPS в СУБД
\*IYottaDB\*P. Вся работа с YottaDB выполняется в сопроцессе, окружение
которого настраивается для вызова процедур MUMPS. Взаимодействие
сопроцесса с основным процессом, где запущен интерпретатор PHP,
выполняется с помощью протокола \*IJSON-RPC\*P.
.PP
Расширение предоставляет следующие функции:
.sp 1.0
.RS
.PI
\*(CWydb_init([env])\*P
.PI
\*(CWydb_finalize()\*P
.PI
\*(CWydb_set(var, keys, ..., val)\*P
.PI
\*(CWydb_gettyped(var, keys, ...)\*P
.PI
\*(CWydb_get(var, keys, ...)\*P
.PI
\*(CWydb_kill(var, keys, ...)\*P
.PI
\*(CWydb_data(var, keys, ...)\*P
.PI
\*(CWydb_order(var, keys, ..., dir)\*P
.PI
\*(CWydb_error()\*P
.PI
\*(CWydb_strerror()\*P
.PI
\*(CWydb_zsinfo(&id, &severity, &text)\*P
.RE
.sp 1.0
.PP
Фукнции \*(CWydb_init\*P и \*(CWydb_finilize\*P используются
инициализация сопроцесса и его завершения. Функции 
\*(CWydb_set\*P, \*(CWydb_gettyped\*P, \*(CWydb_get\*P,
\*(CWydb_kill\*P, \*(CWydb_data\*P и \*(CWydb_order\*P содержат основной
функционал расширения и предназначены для манипуляции переменными MUMPS.
Последние три функции \*- \*(CWydb_error\*P, \*(CWydb_strerror\*P и
\*(CWydb_zsinfo\*P позволяют извлекать информацию о произошедших
ошибках.
.
.H "1. Обработка ошибок"
.PP
Большинство функций в случае ошибки возвращают \*(CWfalse\*P. Код ошибки
можно получить с помощью функции \*(CWydb_error\*P, возвращающей его в
виде целого числа. Все ошибки можно разделить на следующиие группы:
.sp 0.5
.RS
.PI \(bu
Ошибки, исходящие от YottaDB.
.PI \(bu
Ошибки, исходящие от операционной системы.
.PI \(bu
Ошибки, исходящие JSON-RPC.
.PI \(bu
Ошибки, определенные данным расширением.
.RE
.sp 0.5
.PP
Ошибки, исходящие от операционной системы и от JSON-RPC могут возникнуть
при вызове любых функций, кроме, функций для обработки ошибок \*-
\*(CWydb_error\*P, \*(CWydb_strerror\*P и \*(CWydb_szinfo\*P. Ошибки,
исходящие от операционной системы описаны в документации по используемой
операционной системе.
.PP
Коды ошибок, исходящие от JSON-RPC определены реализацией JSON-RPC,
используемой данным расширением. Для них определены следующие константы:
.sp 1.0
.RS
.PI
\*(CWYP_ERR_JRPARSE\*P \*- ошибка при разборе JSON-запроса или
JSON-ответа.
.PI
\*(CWYP_ERR_JRINVALREQ\*P \* неправильно составлен JSON-запрос.
.PI
\*(CWYP_ERR_JRUNKNOWNMETHOD\*P \*- метод, указанный в JSON-запросе не
существует.
.PI
\*(CWYP_ERR_JRINVALPARAMS\*P \*- неправильно составлен список параметров
в JSON-запросе.
.PI
\*(CWYP_ERR_JRINVALRES\*P \*- неправильно составлен JSON-ответ.
.PI
\*(CWYP_ERR_JRALLOC\*P \*- произошла ошибка при выделении диманической
памяти.
.RE
.sp 1.0
Как правило, при корректной работе расширения, таких ошибок возникать
не должно.
.PP
Далее будут в основном описаны ошибки, определённые расширением и
ошибки, исходящие от YottaDB. Для кодов ошибок, определённых
расширением, имеются следующие константы:
.sp 1.0
.RS
.PI
\*(CWYDB_ERR_LASTCLD\*P \*- больше нет индексов для обхода.
.PI
\*(CWYDB_ERR_NUMOFRANGE\*P \*- слишком большое числовое значение.
.PI
\*(CWYDB_ERR_STR2LONG\*P \*- превышена максимальная длина строки.
.PI
\*(CWYDB_ERR_NOTINITILIZED\*P \*- окружение не было инициализировано.
.PI
\*(CWYDB_ERR_ALLOC\*P \*- не удалось выделить память.
.PI
\*(CWYDB_ERR_ENV\*P \*- ошибка при установке переменных окружения.
.PI
\*(CWYDB_ERR_WRONGARGS\*P \*- функции были переданы неверные аргументы.
.RE
.sp 1.0
.PP
Коды ошибок YottaDB определены в формате \*(CWYDB_ERR_ID\*P, где
\*(CWID\*P \*- идентификатор сообщения YottaDB (см. [1], раздел
\*QZMessage Codes\*U). При получении одного из таких кодов,
можно вызвать функцию
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_zsinfo(&id, &severity, &text)
.KE
.sp 0.5v
, которая возвращает информацию из внутренней переменной YottaDB
\*(CW\[u0024]ZSTATUS\*P (см. [2], разделы \*Q8. Intristic Special Variables\*U
и \*Q13. Error Processing\*U) через передаваемые по ссылке строковые
аргументы \*(CWid\*P, \*(CWseverity\*P и \*(CWtext\*P.
.PP
Поле \*(CWid\*P является текстовым и содержит идентификатор сообщения
YottaDB (см. [1], раздел \*QZMessage Codes\*U). Числовое поле
\*(CWseverity\*P указывает на серьёзность ошибки и может принимать одно
из значений, определённых следующими константами:
.sp 1.0
.RS
.PI
\*(CWYDB_SEVERITY_ERROR\*P
.PI
\*(CWYDB_SEVERITY_FATAL\*P
.PI
\*(CWYDB_SEVERITY_INFORMATIONAL\*P
.PI
\*(CWYDB_SEVERITY_SUCCESS\*P
.PI
\*(CWYDB_SEVERITY_WARNING\*P
.RE
.sp 1.0
, которые соответствуют аналогичным константам, приведенным в [3], в
разделе \*QSeverity\*U. Текстовое поле \*(CWtext\*P содержит текстовое
описание ошибки.
.PP
Текстовое описание существует для всех ошибок. Его можно получить с
помощью функции \*(CWydb_strerror\*P, возвращающей это описание как
строку. При внутренних ошибках базы возвращается тот же текст, что 
функция \*(CWydb_zstatus\*P помещает в свой аргумент \*(CWtext\*P.
.
.
.H "1. Начало и завершение работы"
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_init([env])
.KE
.sp 0.5v
предназначена для подготовки окружения к работе с базой данных и всегда
вызывается прежде, чем будут вызваны любые другие функции данного
расширения. Её единственный аргумент, \*(CW[env]\*P, опционален и
является ассоциативным массивом, где ключами являются имена переменных
окружения, которые необходимо задать при инициализации базы данных, а
элементами \*- значения этих переменных (полный список переменных
окружения, используемых для настройки YottaDB, см. в [4], раздел
\*Q3. Basic Operations\*U).
.PP
При отсутствии аргумента \*(CW[env]\*P или каких либо его элементов,
соответствующих переменным окружения, необходимым для инициализации
работы с базой данных, будет выполнено подключение со значениями этих
переменных в соответсвии с настройками YottaDB в локальной системе. В
случае успеха данная функция возвращает \*(CWtrue\*P, иначе \*-
\*(CWfalse\*P. Функция \*(CWydb_init\*P может вернуть следующие ошибки:
.sp 0.5
.RS
.PI \(bu
\*(CWYDB_ERR_WRONGARGS\*P \*- если хотя бы один из переданных аргументов
не является строкой.
.PI \(bu
\*(CWYDB_ERR_CONFIG\*P \*- если в .ini файлах PHP отсутствуюет строка,
указывающая путь к файлам расширения, содержащим процедуры на
\*Iязыке M\*P.
.PI \(bu
\*(CWYDB_ERR_ENV\*P \*- если не удалось установить в хотя бы одну
переменную окружения из тех, что были указаны в аргументах.
.PI \(bu
Любая ошибка YottaDB, которая может возникнуть при инициализации
окружения процесса для работы с базой данных.
.RE
.sp 0.5
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_finalize()
.KE
.sp 0.5v
возвращает окружение в то состояние, в котором оно было до последнего
вызова \*(CWydb_init\*P. Эта функция вызывается всегда, после того, как
работа с базой данных завершена. Как и \*(CWydb_init\*P, в случае успеха
возвращает \*(CWtrue\*P, а при ошибке возвращает \*(CWfalse\*P.
.
.
.H "2. Функции для работы с переменными MUMPS"
.PP
Функции \*(CWydb_set\*P, \*(CWydb_gettyped\*P, \*(CWydb_get\*P,
\*(CWydb_kill\*P, \*(CWydb_data\*P и \*(CWydb_order\*P, предназначены
для работы с переменными \*IMUMPS\*P.
.PP
Первые аргументы, \*(CWvar\*P и произвольное число аргументов
\*(CWkeys\*P, для всех этих функций задают переменную или элемент
массива, с которым необходимо выполнить действие. Аргумент \*(CWvar\*P
является строкой, указывающей имя переменной. Если имя переменной
начинается с символа \*Q\*(CW^\*P\*U, то она является глобальной, иначе
переменная является  локальной и исчезает после вызова
\*(CWydb_finalize\*P.
.PP
В случае, если переменная \*(CWvar\*P является массивом, за ней следует
произвольное число аргументов \*(CWkeys\*P, указывающих индексы её
элемента, с которыми необходимо выполнить действие, идущие от
старшего индекса к младшему.
.PP
Каждый из аргументов \*(CWkeys\*P может являться строкой, целым числом,
числом плавающей точкой или массивом PHP с целочисленными ключами,
содержащим перечисленные значения перечисленных типов. Если аргумент
\*(CWkeys\*P является строкой или числом, то он указывает один индекс.
Если же \*(CWkeys\*P является массивом, то он содержит несколько идущих
подряд, индексов, от старшего к младщему.
.PP
Имя переменной и индексов должны соответствовать правилам именования
переменных MUMPS (см. [2], раздел \*Q5. General Language Features of
M\*U). Также на имена переменных и индексов накладываются ограничения
самой YottaDB: длина имени переменной не должна превышать 31 символ,
количество индексов не должно превышать 31. Помимо этого существуют
ограничения на объем памяти, занимаемый всеми ключами вместе с именем
переменной (см. [4], раздел \*Q4. Global Directory Editor\*U).
.PP
Возможны следующие ошибки, связанные с передачей индексов:
.sp 0.5
.RS
.PI \(bu
\*(CWYDB_ERR_ALLOC\*P \*- не удалось выделить динамическую память.
.PI \(bu
\*(CWYDB_ERR_WRONGARGS\*P \*- переданный аргумент, элемент массива,
переданного в качестве аргумента или один из ключей этого массива имеет
неверный тип данных.
.PI \(bu
\*(CWYDB_ERR_MAXNRSUBSCRIPTS\*P, если количество индексов, переданных
функции, превыщает 31.
.PI \(bu
\*(CWYDB_ERR_KEY2BIG\*P, если объем памяти, занимаемый переданным именем
глобальной переменной превышает ограничение, заданное настройками базы
данных.
.PI \(bu
\*(CWYDB_ERR_GVSUBOFLOW\*P, если объем памяти, занимаемый переданными
\*Iиндексами вместе с именем глобальной переменной\*P
превышает ограничение, заданное настройками базы данных.
.PI \(bu
\*(CWYDB_ERR_NUMOOFRANGE\*P, если индекс, переданный в качестве числа с
плавающей точкой или целого выходит за пределы ограничений, определённых
в YottaDB для такого числа (см. приложение).
.PI \(bu
\*(CWYDB_ERR_STR2LONG\*P, если индекс, переданный в качестве строки,
превышает максимально возможную длину строки, определённую настройками
базы данных.
.PI \(bu
Любая другая ошибка YottaDB, которая может возникнуть при попытке
обращения к переменной MUMPS.
.RE
.sp 0.5
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_set(var, keys, ..., val)
.KE
.sp 0.5v
устанавливает значение переменной или элемента массива MUMPS. Аргумент
\*(CWval\*P может быть строкой, целым числом, числом с плавающей точкой
и булевым значением. Булево значение \*(CWfalse\*P преобразуется в
число 0, а значение \*(CWtrue\*P преобразуется в 1. В случае ошибки
возвращает \*(CWfalse\*P, иначе возвращает \*(CWtrue\*P. Помимо ошибок
связанных с передачей имени переменной и индексов, данная функция может
вернуть следующие ошибки:
.sp 0.5
.RS
.PI \(bu
\*(CWYDB_ERR_NUMOOFRANGE\*P, если аргумент \*(CWval\*P,  является числом
с плавающей точкой или целым и выходит за пределы ограничений,
определённых в YottaDB для такого числа (см. приложение).
.PI \(bu
\*(CWYDB_ERR_STR2LONG\*P, если аргумент \*(CWval\*P, является строкой и
превышает максимально возможную длину строки, определённую настройками
базы данных.
.PI \(bu
Любая другая ошибка YottaDB, которая может возникнуть при установке
переменной MUMPS.
.RE
.sp 0.5
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_gettyped(var, keys, ...)
.KE
.sp 0.5v
возвращает значение переменной или элемента массива MUMPS. Определение
типа выполняется автоматически \*- это может быть число с плавающей
точкой, целое число или строка. Если значение является числом без
десятичного разделителя и других символов, за исключением знака
\*Q\*(CW+\*P\*U или \*Q\*(CW-\*P\*U в начале, длина которого не
превышает 18 цифр, возвращается целое число (тип \*(CWinteger\*P). Если
же значение является любым другим числом, возможным в MUMPS,
возвращается число с плавающей точкой (тип \*(CWfloat\*P). При любом
другом значении возвращается строка (тип \*(CWstring\*P). Если значение
содержит число только частично, также возвращается строка. В случае
ошибки возвращается \*(CWfalse\*P.
.PP
Помимо ошибок, связанных с передачей имени переменной и индексов данная
функция может вернуть следующие ошибки:
.sp 0.5
.RS
.PI \(bu
\*(CWYDB_ERR_OOFRANGE\*P, если значение переменной MUMPS является целым
числом или числом с десятичным разделителем и оно больше максимально
возможного или меньше минимально возможного числа этого типа в PHP
(см. приложение).
.PI \(bu
\*(CWYDB_ERR_STR2LONG\*P, если значение переменной MUMPS является
строкой и его длина превышает максимально возможную длину строки,
определенную настройками PHP.
.PI \(bu
\*(CWYDB_ERR_GBUNDEF\*P, если запрашивается глобальная переменная,
которой не существует.
.PI \(bu
\*(CWYDB_ERR_LVUNDEF\*P, если запрашивается локальная переменная,
которой не существует.
.PI \(bu
\*(CWYDB_ERR_INVSVN\*P, если запрашивается встроенная специальная
переменная, которой не существует.
.RE
.sp 0.5
.PP
В случае, если переменная MUMPS содержит числовое значение, которое
невозможно преобразовать в значение PHP соответствующего типа, можно
использовать функцию
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_get(var, keys, ...)
.KE
.sp 0.5v
, возвращающую значение любой переменной MUMPS в виде строки. В случае
ошибки данная функция, как и другие подобные функции, возвращает
\*(CWfalse\*P. Список ошибок, которые может вернуть данная функция,
аналогичен списку возвращаемых ошибок для функции \*(CWydb_gettyped\*P,
за исключением отсутствия ошибки \*(CWYDB_ERR_OOFRANGE\*P.
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_kill(var, keys, ...)
.KE
.sp 0.5v
удаляет переменную или элемент массива MUMPS. Возвращает \*(CWtrue\*P в
случае успеха и \*(CWfalse\*P в случае ошибки. Данная функция может
вернуть только ошибки, связанные с передачей имени переменной и
индексов. В случае, если удаляется несуществующая переменная или
элемент массива, функция возвращает \*(CWtrue\*P не совершая никаких
действий.
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_data(var, keys, ...)
.KE
.sp 0.5v
возвращает целое число, содержащее информацию о состоянии переменной
или элемента массива MUMPS:
.sp 0.5
.RS
.PI \(bu
Если переменная или элемент массива не определён, возвращается
\*(CW0\*P.
.PI \(bu
Если переменная или элемент массива имеет значение, но не имеет
потомков, возвращается \*(CW1\*P.
.PI \(bu
Если переменная или элемент массива не имеет значения, но имеет
потомков, возвращается \*(CW10\*P.
.PI \(bu
Если переменная или элемент массива имеет значение и имеет потомков,
возвращается \*(CW11\*P.
.PI \(bu
В случае ошибки возвращает \*(CWfalse\*P. Данная функция может только
ошибки, связанные с передачей имени переменной и индексов.
.RE
.sp 0.5
.PP
Функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_order(var, keys, ..., dir)
.KE
.sp 0.5v
используется для итерации по индексам массива MUMPS. Аргумент
\*(CWdir\*P указывает порядок обхода индексов: если он равен \*(CW1\*P
возвращается следующий индекс в переданном ей массиве, если же он равен
\*(CW-1\*P, возвращается предыдущий индекс. Порядок обход индексов
определяется по правилам сортировки значений MUMPS. В случае ошибки,
возвращается \*(CWfalse\*P. Помимо ошибок, связанных с передачей имени
переменной и индексов, данная функция может вернуть следующие ошибки:
.sp 0.5
.RS
.PI \(bu
\*(CWYDB_ERR_LASTCLD\*P, если закончились индексы для обхода.
.PI \(bu
\*(CWYDB_ERR_ORDER2\*P, если аргумент \*(CWdir\*P не равен \*(CW1\*P или
\*(CW-1\*P.
.RE
.sp 0.5
.
.
.H "3. Примеры"
Определение глобальной переменной \*Q\*(CW^country\*P\*U со значением
\*Q\*(CWRussia\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	ydb_set("^country", "Russia");
.KE
.sp 0.5v
Определение глобального массива \*Q\*(CW^person\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	\[u0024]p = array("Komi Republic", "Syktyvkar");
	ydb_set("^person", \[u0024]p, 1, "name", "Ivan");
	ydb_set("^person", \[u0024]p, 1, "surname", "Ivanov");
	ydb_set("^person", \[u0024]p, 2, "name", "Vasiliy");
	ydb_set("^person", \[u0024]p, 2, "surname", "Vasil'ev");

	ydb_set("^person", "Komi Republic", "Ukhta", 1,
		"name", "Dmitiy");
	ydb_set("^person", "Komi Republic", "Ukhta", 1,
		"surname", "Dmitriev");
.KE
.KS
.nf
.in \n[PI]u
.CW

	\[u0024]p = array("Kirovskaya Oblast'", "Kirov");
	ydb_set("^person", \[u0024]p, 1, "name", "Pyotr");
	ydb_set("^person", \[u0024]p, 1, "surname", "Petrov");
	ydb_set("^person", \[u0024]p, 2, "name", "Aleksey");
	ydb_set("^person", \[u0024]p, 2, "surname", "Alekseev");
.KE
.sp 0.5v
Вывод значения глобальной переменной  \*(CW^country\*P:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	echo ydb_gettyped("^country");
.KE
.sp 0.5v
результат:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	Russia
.KE
.sp 0.5v
Вывод значения значений отдельных элементов глобального массива
\*Q\*(CW^person\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	\[u0024]p = array("Komi Republic", "Syktyvkar");
	echo ydb_gettyped("^person", \[u0024]p, 2, "name"),
		" ", ydb_gettyped("^person", \[u0024]p, 2, "surname"), "\\n";

	\[u0024]p = array("Kirovskaya Oblast", "Kirov");
	echo ydb_gettyped("^person", \[u0024]p, 1, "surname"),
		" ", ydb_gettyped("^person", \[u0024]p, 1, "surname"), "\\n";
.KE
.sp 0.5v
Результат:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	Vasiliy Vasil'ev
	Pyotr Petrov
.KE
.sp 0.5v
Удаление элемента глобального массива \*Q\*(CW^person\*P\*U вместе со
всеми его дочерними элементами:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW

	ydb_kill("^person", "Komi Republic", "Ukhta");
.KE
.sp 0.5v
Получение информации о глобальной переменной \*Q\*(CW^country\*P\*U и
отдельных элементах глобального массива \*Q\*(CW^person\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	echo ydb_data("^country"), "\\n";
	echo ydb_data("^person", "Komi Republic", "Ukhta", 2), "\\n";
	echo ydb_data("^person", "Komi Republic", "Syktyvkar",
		1, "name"), "\\n";
	echo ydb_data("^person", "Komi Republic"), "\\n";
.KE
.sp 0.5v
Результат:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
1
0
1
10
.KE
.sp 0.5v
Получение отдельных индексов глобального массива \*Q\*(CW^person\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	echo ydb_order("^person", "Komi Republic",
		"Syktyvkar", 1), "\\n";
	echo ydb_order("^person", "Komi Republic",
		"Syktyvkar", 1), "\\n";
.KE
.sp 0.5v
Результат:	
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	1
	2
.KE
.sp 0.5v
Обход всех дочерних элементов другого элемента глобального массива
\*Q\*(CW^person\*P\*U:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
	\[u0024]p = array("Kirovskaya Oblast'", "Kirov");
	while ((\[u0024]k = ydb_order("^person", \[u0024]p, 1))) {
		\[u0024]v = ydb_gettyped("^person", \[u0024]p, \[u0024]k, "name");
		...
	}

	assert(ydb_error() == YDB_ERR_LASTCLD);
.KE
.sp 0.5v
.
.
.H "Приложение. Преобразование разных типов данных между PHP и YottaDB"
.PP
При преобразовании типов данных между YottaDB и PHP существуют
ограничения. Они появляются из-за того, что одни и те же типы данных
в PHP и YottaDB имеют разное внутреннее представление.
.PP
YottaDB хранит значения всех переменных и элементов массивов в виде
строк, но при этом, при выполнении арифметичеких вычислений, преобразует
данные строки в числа. Числа и строки в MUMPS имеют следующие
ограничения:
.sp 0.5v
.RS
.PI \(bu
Максимальная длина строки определяется настройками базы данных и при
этом никогда не может превышать 1мб.
.PI \(bu
Целое число не может состоять более чем из 18 цифр.
.PI \(bu
Число с плавающей точкой может иметь до 18 значащих цифр и должно лежать
в диапазоне $[ ^ 10 sup -43 ; ~ 10 sup 47 ]$.
.RE
.sp 0.5v
.PP
PHP также имеет свои ограничения, связанные с типами данных Си и
зависящие от архитектуры компьютера:
.sp 0.5v
.RS
.PI \(bu
Максимальная длина строки определяется настройками PHP, но не может
превышать 2гб для 32-битных архитектур и практически не имеет
ограничений для 64-битных архитектур.
.PI \(bu
Целое число должно лежать в диапазоне
$[-2 sup 31 + 1 ; ~ 2 sup 31 - 1]$ для 32-битных архитектур и в
диапазоне $[-2 sup 63 + 1 ; ~ 2 sup 63 - 1]$ для 64-битных архитектур.
.PI \(bu
Число с плавающей точкой на большинстве архитектур соответствует числу
двойной точности из стандарта \*IIEEE 754-2008\*P. Такое число может
иметь от 15 до 17 значащих цифр и лежит в диапазоне
$[ ^ 10 sup -308 ; ~ 10 sup 308 ^ ]$.
.RE
.sp 0.5v
.PP
Если ограничения для строк зависят как от настроек базы данных, так и от
настроек PHP, то ограничения для чисел зависят только от архитектуры и
их можно представить в следующем виде:
.sp 1.0v
.TS
allbox;
c c s c s
^ c c c c
c c c c c.
Тип	из YottaDB в PHP	из PHP в YottaDB
	Зн. цифры	Диапазон	Зн. цифры	Диапазон
32-битное целое	-	[-2^31+1;2^31-1]	-	[-2^31+1;2^31-1]
64-битное целое	18	[-2^63+1;2^63-1]	18	[-2^63+1;2^63-1]
Число с плавающей точкой	15-17	[1E-43;1e47]	15	[1E-43;1e47]
.TE
.sp 1.0v
.PP
Как уже было упомянуто выше, если число при преобразовании выходит за
пределы этих ограничений, возвращается ошибка. Причем, в случае с целыми
числами ошибка возвращается всегда, а в случае с числами с плавающей
точкой происходит преобразование с потерей точности и ошибка возникает
только тогда, когда число выходит за пределы диапазона своих значений.
.
.H "Ссылки"
.RS
.PI 1.
\*(CWhttps://docs.yottadb.com/MessageRecovery\*P \*- Message and
Recovery Procedures Manual.
.PI 2.
\*(CWhttps://docs.yottadb.com/ProgrammersGuide\*P \*- M
programmer's Guide
.PI 3.
\*(CWhttps://docs.yottadb.com/MultiLangProgGuide\*P \*- MultiLanguage
Programmers Guide.
.PI 4.
\*(CWhttps://docs.yottadb.com/AdminOpsGuide\*P \*- Administration and
Operations Guide.
.RE
.
.
.H "Соображения"
.RS
.PI \(bu
У варианта с функциями, имеющими произвольное число аргументов, есть
недостатки, возможно от него придётся откзаться, например, когда
нужно передать сразу два элемента массива.
.PI \(bu
К функции \*(CWydb_data\*P, возможно, стоит добавить дополнительные
мини-функции для работы с её возвращаемыми значениями:
\*(CWYDB_HAVEVAL(n)\*P и \*(CWYDB_HAVECLD(n)\*P.
.PI \(bu
Наверное, еще стоит добавить аналог команд \*(CWLOCK\*P и \*(CWMERGE\*P,
а возможность вызова пользовательских функций.
.PI \(bu
Я определенно не до конца разобрался с числами с плавающей точкой. Что
двигаться дальше, придётся.
.PI \(bu
Индексы могут принимать значение null, надо будет разобраться с этим.
.RE
